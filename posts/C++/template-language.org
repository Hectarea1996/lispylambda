#+TITLE: T++: El lenguaje oculto tras los Templates
#+date:<2023-07-30 do.>

Te propongo lo siguiente: Vamos a aprender un lenguaje de programación nuevo. Lo llamaremos *T++*. Es un lenguaje funcional puro, pero no te preocupes, iremos poco a poco si nunca te has enfrentado con algo así.

T++ es un lenguaje que se usa sobre C++. Por ello, podemos crear una función ~main~ común y corriente para poder comprobar el código que vayamos haciendo. Además, incluiremos una librería indispensable para poder usar T++: *type_traits*.

#+begin_src C++
  #include <iostream>
  #include <type_traits>

  // Aqui declararemos todas las funciones

  int main(){

	  // Aquí porbaremos las funciones

	  return 0;
  }
#+end_src

* Introducción
En T++ los protagonistas serán los tipos de datos. Todo van a ser tipos de datos. Da igual si estamos usando una constante o una función, éstos se representarán mediante tipos de datos de C++.

Sin embargo, para poder hacer cosas interesantes, la mayoría de tipos que usaremos estarán templatizados. En particular, haremos un uso extensivo de las conocimas meta-funciones.

Una meta-función es una estructura templatizada con, al menos, un atributo denominado ~type~. Este atributo es un tipo de dato que representará el resultado de la meta-función. Por ejemplo, podemos definir de la siguiente manera la meta-función identidad:

#+begin_src C++
template<typename T>
struct identity{
  using type = T;
};
#+end_src 

La forma de usar esta meta-función es sencilla:

#+begin_src C++ :exports both :eval never-export :results output :includes '(<iostream> </home/hectarea/lispylambda/posts/C++/prueba.h>)
identity<int>::type myInteger = 3;
std::cout << myInteger << std::endl;
#+end_src

#+RESULTS:
: 3

Observa como se está usando ~identity<int>::type~. La meta-función ~identity~ está recibiendo el argumento ~int~ que lo devuelve a través de ~type~.

Cuando usamos una meta-función de esta manera decimos que estamos *evaluando* la meta-función. Sólo queda decir que estas meta-funciones van a ser el núcleo de T++ y serán lo que nos permita hacer cosillas interesantes en tiempo de compilación.

* Constantes
Y sin esperar mucho más, vamos a definir cuáles van a ser las constantes en T++. Decimos que un tipo de C++ es una constante si es una meta-función que se evalúa a sí misma. Aunque parezca raro, esto se puede hacer sin problemas.

Empecemos por algo sencillo. Los enteros. Queremos crear un tipo de datos que represente, dependiendo de un argumento, a cada uno de los enteros. Como los templates pueden aceptar enteros, la solución es sencilla. Además, recuerda que se tiene que evaluar a sí misma:

#+begin_src C++
template<int n>
struct int_constant{
  using type = int_constant;
};
#+end_src

¡Hecho! Observa que la meta-función devuelve ~int_constant~. A priori, parece que no sea lo mismo que ~int_constant<n>~, pero para C++ sí lo es. Es una manera sencilla que tiene el lenguaje para indicar que queremos devolver el mismo tipo en el que nos encontramos.

Aunque aún falta algo. Para crear una meta-función como se merece tenemos que definir un alias para la evaluación. Esto permitirá más adelante escribir menos código. Este alias tiene el mismo nombre que la meta-función, pero además se le añade el sufijo ~_t~:

#+begin_src C++
template<int n>
using int_constant_t = typename int_constant<n>::type;
#+end_src

Este alias recibe exactamente los mismos argumentos que la meta-función y la evalúa. Observa que hemos tenido que añadir ~typename~. Esto es debido a que tenemos que indicarle al compilador que vamos a recibir un tipo de dato cuando usamos un argumento del template.

Y por ese ~typename~ es que creamos el alias. En lugar de usar

#+begin_src C++
typename int_constant<n>::type;
#+end_src

ahora sólo tenemos que escribir

#+begin_src C++
int_constant_t<n>;
#+end_src

Más cortito y ya no se nos olvidará ese dichoso ~typename~.

* Entre C++ y T++
Aunque hablemos principalmente de T++, el objetivo final es encontrar una manera de usar este nuevo lenguaje en perfecta armonía con C++. Para ello, vale la pena definir los puentes entre los dos lenguajes.

Vamos a observar de nuevo la definición de ~int_constant~:

#+begin_src C++
template<int n>
struct int_constant{
  using type = int_constant;
};
#+end_src

Observa que el argumento que recibe es un valor de C++. Por tanto, estamos ante un puente entre C++ y T++. Pero sólo va en una dirección: dado un valor de C++ conseguimos una constante de T++. También nos puede interesar el camino opuesto. Para ello, vamos a añadir un atributo extra que denominaremos ~value~. Este atributo simplemente tendrá el mismo valor que el argumento:

#+begin_src C++
template<int n>
struct int_constant{
  using type = int_constant;
  static constexpr int value = n;
};
#+end_src

Fíjate que hemos añadido ~static~ y ~constexpr~ a la declaración del atributo ~value~. Con ~static~ conseguimos que el atributo forme parte del struct y no de los objetos de tipo dicho struct. Y con ~constexpr~ conseguimos formar a que el valor de ~value~ esté disponible en tiempo de compilación.

Por último, al igual que con ~type~, nos interesa crear un alias:

#+begin_src C++
template<int n>
extern constexpr int int_constant_v = int_constant<n>::value;
#+end_src

Aquí ~constexpr~ sirve para lo mismo que con ~value~. Por otro lado, usamos ~extern~ para hacer que su tipo de lincado sea externo. De esta forma podemos poner la declaración en un header sin problemas.

Podemos comprobar si funciona:

#+begin_src C++ :exports both :eval never-export :results output :includes '(<iostream> </home/hectarea/lispylambda/posts/C++/prueba.h>)
std::cout << int_constant_v<5> << std::endl;
#+end_src

#+RESULTS:
: 5

Perfecto.

Pues ahora que sabemos cómo establecer un puente entre T++ y C++ basta crear una constante para cada tipo de C++. Es decir, podemos crear constantes para booleanos, floats, doubles. Aunque, ya que estamos, deberíamos hacerlo para int8_t, int16_t, unsigned int, uint8_t, uint32_t... ¡Ufff! ¡Qué pereza!

¿No podemos crear alguna constante que represente a cualquier valor de C++?

* La constante 'box'
Desde el estandar C++17 es válido indicar como argumento de un template un valor con el especificador ~auto~. De esta forma podemos conseguir definir una constante que represente un puente en T++ y C++ para todos los valores primitivos de C++.

#+begin_src C++
template<auto b>
struct box{
  using type = box;
  static constexpr auto value = b; 
};

template<auto b>
using box_t = typename box<b>::type;

template<auto b>
extern constexpr auto box_v = box<b>::value;
#+end_src

Al igual que con ~int_constant~, definimos los atributos ~type~ y ~value~ así como los alias ~_t~ y ~_v~.

Vamos a probar:

#+begin_src C++ :exports both :eval never-export :results output :includes '(<iostream> </home/hectarea/lispylambda/posts/C++/prueba.h>)
std::cout << box_v<5> << std::endl;
std::cout << box_v<'k'> << std::endl;
#+end_src

#+RESULTS:
: 5
: k

¡Genial!
 
* Funciones
Una vez hemos visto las constantes necesitamos algo que nos permita hacer cálculos con ellos. Y ahí es cuando entran las funciones. Definimos las funciones en T++ a aquellas meta-funciones que se evalúan a una constante.

Por ejemplo, podemos definir una función que reciba dos enteros (~box<n>~ con ~n~ de tipo ~int~) y que devuelva la suma:

#+begin_src C++
template<typename A, typename B>
struct add2 : box<A::value + B::value>{};
#+end_src

Espera un momento... ¿Qué está pasando aquí? ¿Eso es una meta-función? ¿Dónde está el atributo ~type~?

Pues aunque parezca mentira, esto cumple perfectamente la definición de meta-función. Es más, es una función de T++ porque se evalúa a una constante, la constante ~box~. 

Observa cómo se ha definido la estructura ~add2~. En particular, fíjate en los '~:~' que hay tras ~add2~. ¡Estamos utilizando herencia! Es decir, estamos heredando de ~box~ y, por tanto, tenemos todos sus atributos. Y recordemos que ~box~ tenía dos atributos: ~type~ y ~value~.

En general, esta forma de definir funciones es 'la correcta'. Usaremos la herencia para definir funciones a no ser que no podamos por las características de la propia función.

Antes de continuar, no nos olvidemos de los alias:

#+begin_src C++
template<typename A, typename B>
using add2_t = typename add2<A,B>::type;

template<typename A, typename B>
extern constexpr auto value = add2<A,B>::value;
#+end_src

Vamos a comprobar que funciona:

#+begin_src C++ :exports both :eval never-export :results output :includes '(<iostream> </home/hectarea/lispylambda/posts/C++/prueba.h>)
std::cout << add2_v<box<5>,box<10>> << std::endl;
#+end_src

#+RESULTS:
: 15

¡Espectacular!

La función de suma se puede generalizar para que acepte una cantidad variable de argumentos:

#+begin_src C++
template<typename... NS>
struct add : box<0>{};

template<typename N, typename... NS>
struct add<N,NS...> : box<N::value+add<NS...>::value> {};

template<typename... NS>
using add_t = typename add<NS...>::type;

template<typename... NS>
extern constexpr auto add_v = add<NS...>::value;
#+end_src

Lo probamos:

#+begin_src C++ :exports both :eval never-export :results output :includes '(<iostream> </home/hectarea/lispylambda/posts/C++/prueba.h>)
std::cout << add_v<box<1>, box<10>, box<9>, box<-100>> << std::endl;
#+end_src

#+RESULTS:
: -80

* Mucho texto...
Asumámoslo, definir una función en T++ requiere mucho texto. En particular, es bastante tedioso tener que escribir cada vez esas versiones cortas acabadas en ~_t~ o ~_v~. ¿Podemos ponerle algún remedio? Pues claro. Si no pudiésemos o no se me hubiese ocurrido nada, no existiría esta sección que estás leyendo. 

A pesar de no tener un buen sistema de macros como sí tienen los lenguajes de la familia Lisp (Common Lisp, Scheme, Clojure o Scheme, entro otros), de algo nos pueden servir en este caso. Y es que el simple hecho de tener el nombre de 'Macro' es una gran injusticia. El sistema de """"""Macros"""""" de C++ no le llega ni  a la suela de los zapatos a uno de verdad. Ahora que ya me he desahogado, podemos proseguir ~:D~.

Si nos fijamos en estas versiones cortas que hemos ido escribiendo, podemos ver algunos patrones que van a ser claves para crear una """"""Macro"""""" (vale, ya paro) que nos facilite un poco la vida. Veamos dos ejemplos:

#+begin_src C++ :exports both :eval never-export :results output :includes '(<iostream> "\"/home/hector/lispylambda/posts/C++/prueba.h\"")
   template<typename N, typename M>
   struct mult : box<N::value * M::value> {};

   template<typename N, typename M>
   using mult_t = typename mult<N,M>::type;  

   template<typename N, typename M>
   extern constexpr auto mult_v = mult<N,M>::value;
 #+end_src

#+begin_src C++ :exports both :eval never-export :results output :includes '(<iostream> "\"/home/hector/lispylambda/posts/C++/prueba.h\"")
template<typename T>
struct is_zero : box<false> {};

template<>
struct is_zero<box<0>> : bool_constant<true> {};

template<typename T>
using is_zero_t = typename is_zero<T>::type;

template<typename T>
extern constexpr auto is_zero_v = is_zero<T>::value;
 #+end_src

Observa, que a pesar de tener diferencias, la definición de las abreviaciones es bastante parecida en ambos casos. Si nos fijamos únicamente en dichas diferencias sabremos qué debe recibir nuestra macro. Es decir, nuestra macro recibirá esas partes que cambian de función a función.

Podemos apreciar ~3~ diferencias en total: El nombre de la función, la declaración de los argumentos de cada template y cómo se pasan dichos argumentos a la función. Por tanto, la macro podría ser de la siguiente manera:

#+begin_src C++ :exports both :eval never-export :results output :includes '(<iostream> "\"~/lispylambda/posts/C++/prueba.h\"")
#define canonize(name, tempArg, call)      \
  tempArgs                                              \
  using name##_t = typename call##::type;               \
                                                        \
  tempArgs                                              \
  extern constexpr auto name##_v = call##::value;
 #+end_src

Y podríamos usarla de la siguiente manera...

#+begin_src C++ :exports both :eval never-export :results output :includes '(<iostream> </home/hectarea/lispylambda/posts/C++/prueba.h>)
canonize(mult, template<typename N, typename M>, mult<N,M>);
 #+end_src

 #+begin_src
 error: macro "canonize" passed 5 arguments, but takes just 3
 #+end_src
 
...si no fuese por las comas entre los argumentos de los templates. ¡Pero no nos rendimos! Además, ¡esta sección existe! ¡debe ser posible! ... ¿verdad?

A ver, busquemos en [[https://en.cppreference.com/w/cpp/preprocessor/replace][cppreference]]: ~Note: if an argument of a function-like macro includes commas that are not protected by matched pairs of left and right parentheses (most commonly found in template argument lists, as in assert(std::is_same_v<int, int>); or BOOST_FOREACH(std::pair<int, int> p, m)), the comma is interpreted as macro argument separator, causing a compilation failure due to argument count mismatch.~

¡Bien! Es lo que nos está ocurriendo y además nos dice cómo podemos solucionarlo. De alguna manera tenemos que introducir las comas entre paréntesis. Pero de alguna manera tenemos que eliminarlos después de que se expanda la macro. ¡Ya sé! Podemos poner dicho argumento entre paréntesis justo al lado de una macro. De esta forma, se ejecutará dicha macro que devolverá el argumento que está recibiendo. Sé que me explico fatal. Por lo que veamos paso a paso cómo hacerlo.

1. Primero definimos la macro ~EXPAND~. Recibe un argumento y lo devuelve, sin más:

#+begin_src C++ :exports both :eval never-export :results output :includes '(<iostream> </home/hectarea/lispylambda/posts/C++/prueba.h>)
#define EXPAND(X) X
 #+end_src

Ahora, sólo tenemos que cambiar ~canonize~ introduciendo una llamada a ~EXPAND~ cada vez que usemos un argumento:

#+begin_src C++ :exports both :eval never-export :results output :includes '(<iostream> "\"~/lispylambda/posts/C++/prueba.h\"")
#define EXPAND(X) X
#define canonize(name, tempArgs, call)                      \
  EXPAND tempArgs                                                       \
  using name##_t = typename EXPAND call ::type;                         \
                                                                        \
  EXPAND tempArgs                                                       \
  extern constexpr auto name##_v = EXPAND call ::value;
 #+end_src

El único argumento que no necesita ~EXPAND~ es ~name~, pues nunca podrá tener una coma al tener que referirse siempre al nombre de una función.

Probemos de nuevo:

#+begin_src C++ :exports both :eval never-export :results output :includes '(<iostream> "\"~/lispylambda/posts/C++/prueba.h\"")
canonize(mult, (template<typename N, typename M>), (mult<N,M>));
 #+end_src

Veamos si funciona:

#+begin_src C++ :exports both :eval never-export :results output :includes '(<iostream> </home/hectarea/lispylambda/posts/C++/prueba.h>)
std::cout << mult_v<box<3>,box<4>> << std::endl;
 #+end_src

 #+RESULTS:
 : 12

¡Perfecto! Ya te dije que esta sección estaba aquí por algo.

Pero podemos hacerlo mejor. Observa el segundo argumento que le pasamos a ~canonize~. Siempre le vamos a pasar la palabra ~template~ al inicio, además de los símbolos ~<~ y ~>~. Por otro lado, en el tercer argumento ocurre algo parecido, siempre vamos a utilizar el nombre de la función para realizar la llamada, pero dicho nombre ya lo estamos recibiendo como primer argumento. Cambiemos un poco la definición:

#+begin_src C++ :exports both :eval never-export :results output :includes '(<iostream> "\"~/lispylambda/posts/C++/prueba.h\"")
#define EXPAND(X) X
#define canonize(name, tempArgs, call)                      \
  template<EXPAND tempArgs>                                                       \
  using name##_t = typename name<EXPAND call> ::type;                         \
                                                                        \
  EXPAND tempArgs                                                       \
  extern constexpr auto name##_v = name<EXPAND call> ::value;
 #+end_src

Su uso quedaria ahora de la siguiente manera:

#+begin_src C++ :exports both :eval never-export :results output :includes '(<iostream> "\"~/lispylambda/posts/C++/prueba.h\"")
canonize(first, (typename C), (C));
 #+end_src

La nueva versión se utilizaría así:

#+begin_src C++ :exports both :eval never-export :results output :includes '(<iostream> "\"~/lispylambda/posts/C++/prueba.h\"")
canonize(mult, (typename N, typename M), (N,M));
 #+end_src

Bastante más cómodo que antes.

¡Pero podemos hacerlo aún mejor! Los argumentos de nuestros templates siempre van a ser tipos. Podemos hacer que todos los templates reciban siempre una cantidad variable de argumentos. Esto es válido, pues hasta que no se use un template, éste no se instancia y C++ no sabrá hasta entonces si la cantidad de argumentos que se ha pasado es correcta o no. Cambiemos de nuevo la definición.

#+begin_src C++ :exports both :eval never-export :results output :includes '(<iostream> "\"~/lispylambda/posts/C++/prueba.h\"")
#define EXPAND(X) X
#define canonize(name)                                  \
  template<typename... TS>                              \
  using name##_t = typename name<TS...> ::type;         \
                                                        \
  template<typename... TS>                              \
  extern constexpr auto name##_v = name<TS...> ::value;
 #+end_src

Espera un momento... Nos hemos quedado con... ¡¿sólo un argumento?! ¡Genial!

#+begin_src C++ :exports both :eval never-export :results output :includes '(<iostream> "\"~/lispylambda/posts/C++/prueba.h\"")
canonize(mult);
 #+end_src

Crear ahora estas abreviaciones es ¡demasiado fácil! ¡Pero funciona!

Lo mejor de todo, es que si en un futuro no muy lejano se nos ocurre añadir alguna nueva abreviación, sólo tendremos que añadirla a nuestra macro, y automáticamente ¡todas nuestras funciones tendrán esa nueva abreviación! 

Vamos a cambiar las definiciones de la función ~identity~ y la función ~add~ para que usen ~canonize~:

#+begin_src C++
/// identity
template<typename T>
struct identity : T {};

canonize(identity);

/// add
template<typename... NS>
struct add : box<0>{};

template<typename N, typename... NS>
struct add<N,NS...> : box<N::value+add<NS...>::value> {};

canonize(add);
#+end_src

Oh si... Mucho más limpio.

También ha aparecido la función ~mult~ que podemos generalizar para que reciba una cantidad variable de argumentos, así como la función ~is_zero~:

#+begin_src C++
/// mult
template<typename... NS>
struct mult : box<1> {};

template<typename N, typename... NS>
struct mult<N,NS...> : box<N::value * mult<NS...>::value> {};

canonize(mult);

/// is_zero
template<typename T>
struct is_zero : box<false>{}; 

template<>
struct is_zero<box<0>> : box<true> {};

canonize(is_zero);
#+end_src

* Más funciones
A partir de aquí podemos hacer todas las funciones que manejen valores primitivos de T++ que se nos ocurran. Aquí tienes unas cuantas que usaremos más adelante. No tienen mucho misterio por lo que no explicaremos para qué sirven ni cómo se han definido.

 #+begin_src C++ :exports both :eval never-export :results output :includes '(<iostream> "\"/home/hector/lispylambda/posts/C++/prueba.h\"")
   /// or operator
   template<typename B, typename C>
   struct or_bool : bool_constant<B::value || C::value> {};

   template<typename B, typename C>
   constexpr bool or_bool_v = or_bool<B,C>::value;

   template<typename B, typename C>
   using or_bool_t = typename or_bool<B,C>::type;


   /// not operator
   template<typename B>
   struct not_bool : bool_constant<!B::value> {};

   template<typename B>
   constexpr bool not_bool_v = not_bool<B>::value;

   template<typename B>
   using not_bool_t = typename not_bool<B>::type;


   /// add1
   template<typename N>
   struct add1 : int_constant<N::value + 1> {};

   template<typename N>
   constexpr int add1_v = add1<N>::value;

   template<typename N>
   using add1_t = typename add1<N>::type;


   /// eql
   template<typename N, typename M>
   struct eql : bool_constant<N::value == M::value> {};

   template<typename N, typename M>
   constexpr bool eql_v = eql<N,M>::value;

   template<typename N, typename M>
   using eql_t = typename eql<N,M>::type;


   /// mod operator
   template<typename A, typename B>
   struct mod : int_constant<A::value % B::value> {};

   template<typename A, typename B>
   constexpr int mod_v = mod<A,B>::value;

   template<typename A, typename B>
   using mod_t = typename mod<A,B>::type;


   /// isDivisor
   template<typename D, typename N>
   struct isDivisor : is_zero<mod_t<N,D>> {};

   template<typename D, typename N>
   constexpr bool isDivisor_v = isDivisor<D,N>::value;

   template<typename D, typename N>
   using isDivisor_t = typename isDivisor<D,N>::type;


   /// hasDivisors
   template<typename D, typename N>
   struct hasDivisors_aux : or_bool<
							   isDivisor_t<D,N>,
							   typename hasDivisors_aux<add1_t<D>,N>::type> {};

   template<typename N>
   struct hasDivisors_aux<N,N> : bool_constant<false> {};

   template<typename N>
   struct hasDivisors : hasDivisors_aux<int_constant_t<2>,N> {};

   template<typename N>
   constexpr bool hasDivisors_v = hasDivisors<N>::value;

   template<typename N>
   using hasDivisors_t = typename hasDivisors<N>::type;


   /// isPrime
   template<typename N>
   struct isPrime : not_bool<hasDivisors_t<N>> {};

   template<typename N>
   constexpr bool isPrime_v = isPrime<N>::value;

   template<typename N>
   using isPrime_t = typename isPrime<N>::type;


   /// nextPrime
   template<typename N, typename IsPrime>
   struct nextPrimeAux : nextPrimeAux<add1_t<N>,isPrime_t<add1_t<N>>> {};

   template<typename N>
   struct nextPrimeAux<N,bool_constant_t<true>> : N {};

   template<typename N>
   struct nextPrime : nextPrimeAux<add1_t<N>,isPrime_t<add1_t<N>>> {};

   template<typename N>
   constexpr int nextPrime_v = nextPrime<N>::value;

   template<typename N>
   using nextPrime_t = typename nextPrime<N>::type;
 #+end_src

Vale, este código es duro de procesar. Pero nos quedamos al menos con la última, que nos permite obtener el siguiente número primo a partir de uno dado. Vamos a probarla.

 #+begin_src C++ :exports both :eval never-export :results output :includes '(<iostream> "\"/home/hector/lispylambda/posts/C++/prueba.h\"")
   std::cout << nextPrime_v<int_constant_t<13>> << std::endl;
 #+end_src 

 #+RESULTS:
 : 17

Todo esto está muy guay, pero falta algo. Con sólo tipos primitivos no conseguimos mucho. Vamos a ver si podemos crear algo más grande.

* Colecciones
Hasta ahora nos hemos centrado en valores primitivos y arrays de estos valores. Pero podemos crear también contenedores de tipos. Uno de estos contenedores los llamaremos colecciones. Aquí va la definición.

#+begin_src C++ :exports both :eval never-export :results output :includes '(<iostream> "\"/home/hector/lispylambda/posts/C++/prueba.h\"")
  template<typename... TS>
  struct collection{
	  using type = collection;
  };

  template<typename... TS>
  using collection_t = typename collection<TS...>::type;
 #+end_src

 Este template recibe una cantidad arbitraria de tipos y... no hace nada con ellos. El simple hecho de estar en la lista de argumentos nos permite 'almacenarlos'. Observa además que en este caso no tiene sentido un atributo ~value~, pues todos los argumentos son tipos que no tienen por qué representar ningún valor, ya sea numérico o de cualquier otro tipo.
 
Como ejemplo podemos crear una función que nos diga si una colección está o no vacía.

#+begin_src C++ :exports both :eval never-export :results output :includes '(<iostream> "\"/home/hector/lispylambda/posts/C++/prueba.h\"")
  template<typename C>
  struct is_empty {};

  template<typename T, typename... TS>
  struct is_empty<collection<T,TS...>> : bool_constant<false> {};

  template<typename... TS>
  struct is_empty<collection<TS...>> : bool_constant<true> {};

  template<typename C>
  constexpr bool is_empty_v = is_empty<C>::value;

  template<typename C>
  using is_empty_t = typename is_empty<C>::type;
 #+end_src

Observa que, como otras funciones que hemos implementado, se usa la especialización de templates. Pues fíjate en el caso general, es decir, la primera de todas. Es un struct vacío, no hereda de nadie ni tiene atributos. Al hacer esto, estamos forzando a que se genere un error si alguien usa esta función si no proporciona una colección como argumento.

Probamos la función.

#+begin_src C++ :exports both :eval never-export :results output :includes '(<iostream> "\"/home/hector/lispylambda/posts/C++/prueba.h\"")
  std::cout << is_empty_v<collection_t<>> << std::endl;
  std::cout << is_empty_v<collection_t<int,float,char>> << std::endl;
 #+end_src

 #+RESULTS:
 : 1
 : 0

Concatenar colecciones también es muy sencillo.

#+begin_src C++ :exports both :eval never-export :results output :includes '(<iostream> "\"/home/hector/lispylambda/posts/C++/prueba.h\"")
  template<typename C, typename D>
  struct concatenate {};

  template<typename... CS, typename... DS>
  struct concatenate<collection<CS...>,collection<DS...>> : collection<CS...,DS...> {};

  template<typename C,typename D>
  using concatenate_t = typename concatenate<C,D>::type;
 #+end_src

Y ahora es cuando tenemos el problema de que no podemos imprimir una colección de tipos. En algunos editores, pasando el ratón por encima de una directiva ~using~, es posible que veas el tipo resultante de aplicar estas funciones. Aunque también hay otro truquillo. Vamos a definir la estructura ~debug~ que nos permitirá ver el resultado de nuestras funciones cuando devuelvan tipos en lugar de valores.

#+begin_src C++ :exports both :eval never-export :results output :includes '(<iostream> "\"/home/hector/lispylambda/posts/C++/prueba.h\"")
  template<typename T>
  struct debug {};
 #+end_src

 Te estarás preguntando qué tiene de especial esta estructura para conseguir visualizar el resultado de nuestras funciones. La respuesta es nada. De hecho, puedes llamar a esta estructura como quieras. Lo que vamos a hacer es forzar un error intentando acceder a un miembro inexistente de la estructura ~debug~. Esto se ve mejor con un ejemplo.

#+begin_src C++ :exports both :eval never-export :results output :includes '(<iostream> "\"/home/hector/lispylambda/posts/C++/prueba.h\"")
  using foo = debug<concatenate_t<collection_t<int,float>,collection_t<char,double>>>::type;
 #+end_src

#+begin_src
  error: 'type' in 'struct debug<collection<int, float, char, double> >' does not name a type
 #+end_src
 
Vaya vaya. Así que no existe el atributo ~type~ en la estructura ~debug<collection<int,float,char,double>>~. Observa bien lo que hay escrito. Dentro de debug tenemos exactamente ~collection<int,float,char,double>~. Y está claro que esa es la concatenación de ~collection_t<int,float>~ y ~collection_t<char,double>~.

Sé que no es el método de debug más elegante, pero al menos funciona. Y si has pensado en usar la librería ~<typeinfo>~... no, no funciona. Aquí una prueba.

#+begin_src C++ :exports both :eval never-export :results output :includes '(<typeinfo> '(<iostream> "\"/home/hector/lispylambda/posts/C++/prueba.h\""))
  std::cout << typeid(concatenate_t<collection_t<int,float>,collection_t<char,double>>).name() << std::endl;
 #+end_src

 #+RESULTS:
 : 10collectionIJifcdEE

Yo la verdad es que no entiendo muy bien lo que pone ahí.

Vamos a detenernos de nuevo en la función concatenate.

#+begin_src C++ :exports both :eval never-export :results output :includes '(<iostream> "\"/home/hector/lispylambda/posts/C++/prueba.h\"")
  template<typename C, typename D>
  struct concatenate {};

  template<typename... CS, typename... DS>
  struct concatenate<collection<CS...>,collection<DS...>> : collection<CS...,DS...> {};

  template<typename C,typename D>
  using concatenate_t = typename concatenate<C,D>::type;
 #+end_src

 Observa la especialización de ~concatenate~. Fíjate en cómo estamos usando la especialización para darle un nombre a los elementos de cada colección. La primera colección tiene unos elementos que identificamos con ~CS~. Y para la segunda colección usamos el identificador ~DS~. Esta facilidad de darle un identificador a los elementos de una colección es lo que hace este tipo de contenedor sea tan útil para los templates de C++.

 Otro ejemplo interesante es la función para invertir el orden de los elementos de una colección.

#+begin_src C++ :exports both :eval never-export :results output :includes '(<iostream> "\"/home/hector/lispylambda/posts/C++/prueba.h\"")
  template<typename C, typename D>
  struct reverse_collection_aux {};

  template<typename... cs, typename... ds>
  struct reverse_collection_aux<collection<cs...>, collection<ds...>>
	  : collection_t<ds...> {};

  template<typename c, typename... cs, typename... ds>
  struct reverse_collection_aux<collection<c,cs...>, collection<ds...>>
	  : reverse_collection_aux<collection_t<cs...>, collection_t<c,ds...>> {};

  template<typename C>
  struct reverse_collection
	  : reverse_collection_aux<C, collection_t<>> {};

  template<typename C>
  using reverse_collection_t = typename reverse_collection<C>::type;
 #+end_src

 De nuevo, la especialización de los templates nos permite dar identificadores a los elementos de una colección, incluso a elementos concretos como en este caso, donde se le da el identificador ~c~ al primer elemento de la colección. Observa que la clave de esta función está en la segunda especialización, donde el elemento ~c~ pasa de la primera colección a la segunda. 

#+begin_src C++ :exports both :eval never-export :results output :includes '(<iostream> "\"/home/hector/lispylambda/posts/C++/prueba.h\"")
  using foo = debug<reverse_collection_t<collection_t<float,char,int>>>::type;
 #+end_src

#+begin_src
  error: 'type' in 'struct debug<collection<int, char, float> >' does not name a type
 #+end_src

Podríamos seguir definiendo funciones para las colecciones, pero sería mejor si llevásemos todo esto un poco más lejos. Sin embargo, necesitamos un tipo de dato que, aunque ya hemos visto, no lo hemos explotado lo suficiente. Me refiero a las funciones.

* Funciones de primera clase
En cualquier lenguaje funcional, las funciones son elementos de primera clase. Tienen su propio tipo y no los hace ni más ni menos especiales que cualquier otro tipo de dato. Sin embargo, en T++, los datos y las funciones se deben de tratar de diferente manera. Basta ver las diferencias entre un entero y la función ~add~. Al definir un entero en T++, estamos definiendo una estructura en C++. Sin embargo, la función ~add~ es una estructura templatizada, y a menos que le proporcionemos los argumentos necesarios, no será una estructura como tal. Todo esto se puede apreciar mejor cuando intentamos crear una función que acepte cada uno de los dos tipos de argumentos.

Esta sería la posible implementación de una función que puede recibir como argumento una función como ~add~.

#+begin_src C++ :exports both :eval never-export :results output :includes '(<iostream> "\"/home/hector/lispylambda/posts/C++/prueba.h\"")
  template<template<typename,typename> typename F>
  struct receiving_function : ... {};
 #+end_src

Y otra que recibiría un entero:

#+begin_src C++ :exports both :eval never-export :results output :includes '(<iostream> "\"/home/hector/lispylambda/posts/C++/prueba.h\"")
  template<typename I>
  struct receiving_integer : ... {};
 #+end_src

Es clara la diferencia. Mientras que en una debemos recibir un ~template<template<typename,typename> typename>~, en la otra recibimos ~template<typename>~.

Lo ideal sería tener un tipo de dato que nos permita manejar funciones al igual que los enteros. De esta forma podremos tener colecciones de funciones, por ejemplo.

Pues manos a la obra. Como no podemos predecir cuántos argumentos podrá recibir una función, podemos indicar que nuestro tipo de dato aceptará funciones con cualquier número de argumentos. Además, al igual que con ~integral_constant~ o las estructuras, definiremos el atributo ~type~ para que sea igual al propio tipo de la función.

También necesitaremos un atributo extra que nos permita ejecutar la función. Dicho atributo lo llamaré ~call~.

#+begin_src C++ :exports both :eval never-export :results output :includes '(<iostream> "\"/home/hector/lispylambda/posts/C++/prueba.h\"")
  template<template<typename...> typename F>
  struct function{
	using type = function;

	template<typename... A>
	using call = typename F<A...>::type;
  };
 #+end_src

Observa que ~call~ es un atributo templatizado. Simplemente recibe los argumentos que tiene que pasarle a la función ~F~.

Crear ahora un objeto de tipo ~function~ es muy sencillo. Por ejemplo, si queremos almacenar la función ~add~, basta usar ~function<add>~. De hecho, algo que deberíamos hacer a partir de ahora, es añadir una nueva definición cada vez que creemos una función nueva. Por ejemplo, para ~add~ deberíamos añadir lo siguiente:

#+begin_src C++ :exports both :eval never-export :results output :includes '(<iostream> "\"/home/hector/lispylambda/posts/C++/prueba.h\"")
  using add_f = function<add>;
 #+end_src

A partir de ahora, supondremos que todas las funciones definidas hasta ahora tienen definida su versión ~_f~. 

Ahora, podemos crear una función que ejecute un objeto de tipo ~function~.

#+begin_src C++ :exports both :eval never-export :results output :includes '(<iostream> "\"/home/hector/lispylambda/posts/C++/prueba.h\"")
  template<typename F, typename... A>
  struct funcall : F::template call<A...> {};

  template<typename F, typename... A>
  using funcall_t = typename funcall<F,A...>::type;

  template<typename F, typename... A>
  static constexpr typename funcall<F,A...>::value_type funcall_v = funcall<F,A...>::value;

  using funcall_f = function<funcall>;
 #+end_src

En lugar de acceder al atributo templatizado ~call~ cada vez que queramos ejecutar una función, usaremos la función ~funcall~. Esta función recibe un objeto de tipo ~function~ y sus argumentos. Devolverá el resultado de ejecutar la función con esos argumentos.

#+begin_src C++ :exports both :eval never-export :results output :includes '(<iostream> "\"/home/hector/lispylambda/posts/C++/prueba.h\"")
  std::cout << funcall_v<add_f,int_constant<5>,int_constant<6>> << std::endl;
 #+end_src

 #+RESULTS:
 : 11
 
Otra función parecida a ~funcall~ es ~apply~. La diferencia está en que el último argumento debe ser una colección de argumentos. De esta forma, la función pasada a ~apply~ es ejecutada con los primeros argumentos pasados más los encontrados en la colección del último argumento.

#+begin_src C++ :exports both :eval never-export :results output :includes '(<iostream> "\"/home/hector/lispylambda/posts/C++/prueba.h\"")
  template<typename F, typename C, typename... A>
  struct apply_aux {};

  template<typename F, typename... CS, typename A, typename B, typename... AS>
  struct apply_aux<F,collection<CS...>,A,B,AS...> : apply_aux<F,collection<CS...,A>,B,AS...> {};

  template<typename F, typename... CS, typename... AS>
  struct apply_aux<F,collection<CS...>,collection<AS...>> : funcall<F,CS...,AS...> {};

  template<typename F, typename... A>
  struct apply : apply_aux<F,collection<>,A...> {};

  template<typename F, typename... A>
  using apply_t = typename apply<F,A...>::type;

  template<typename F, typename... A>
  static constexpr typename apply<F,A...>::value_type apply_v = apply<F,A...>::value;

  using apply_f = function<apply>;
 #+end_src

Como no podemos obtener directamente el último argumento de una colección, debemos ir guardando cada uno de los argumentos anteriores hasta que sepamos que sólo nos queda uno (el último). En ese momento, ejecutamos la función usando ~funcall~.

Para probarla, podemos definir una nueva función que sume todos los enteros de una colección. Normalmente necesitaríamos recorrer la colección usando recursividad, pero con ~apply~, es innecesario:

#+begin_src C++ :exports both :eval never-export :results output :includes '(<iostream> "\"/home/hector/lispylambda/posts/C++/prueba.h\"")
  template<typename C>
  struct sum : apply<add_f,C> {};

  template<typename C>
  using sum_t = typename sum<C>::type;

  template<typename C>
  static constexpr int sum_v = sum<C>::value;

  using sum_f = function<sum>;
 #+end_src

Demasiado fácil para ser verdad. Pero funciona.

#+begin_src C++ :exports both :eval never-export :results output :includes '(<iostream> "\"/home/hector/lispylambda/posts/C++/prueba.h\"")
  using myList = collection_t<int_constant<1>,int_constant<2>,int_constant<3>>;

  std::cout << sum_v<myList> << std::endl;
 #+end_src

 #+RESULTS:
 : 6

* Más colecciones

Las colecciones son bastante útiles y por eso vale la pena seguir definiendo funciones que nos permitan manipularlas con facilidad. Por ahora tenemos ~is_empty~, ~concatenate~, ~reverse_collection~ y ~first~. Vamos a intentar definir aquellas que son básicas, aquellas que nos permitan añadir elementos, contarlos, etc.

Empezamos con ~cons~. Esta función añade un elemento al inicio de una colección.

#+begin_src C++ :exports both :eval never-export :results output :includes '(<iostream> "\"~/lispylambda/posts/C++/prueba.h\"")
template<typename V, typename C>
struct cons {};

template<typename V, typename... CS>
struct cons<V, collection<CS...>> : collection<V,CS...> {};

canonize(cons);
 #+end_src

El argumento ~V~ es el elemento que queremos insertar, y el segundo argumento es la colección donde queremos insertar el elemento.

#+begin_src C++ :exports both :eval never-export :results output :includes '(<iostream> </home/hectarea/lispylambda/posts/C++/prueba.h>)
std::cout << first_v<cons_t<int_constant<5>,collection<int_constant<7>>>> << std::endl;
 #+end_src

 #+RESULTS:
 : 5

Si podemos añadir elementos, también deberíamos poder eliminarlos. Creamos la función ~rest~.

#+begin_src C++ :exports both :eval never-export :results output :includes '(<iostream> "\"~/lispylambda/posts/C++/prueba.h\"")
template<typename C>
struct rest {};

template<typename C, typename... CS>
struct rest<collection<C,CS...>> : collection<CS...> {};

template<typename... CS>
struct rest<collection<CS...>> : collection<CS...> {};

canonize(rest);
 #+end_src

#+begin_src C++ :exports both :eval never-export :results output :includes '(<iostream> </home/hectarea/lispylambda/posts/C++/prueba.h>)
std::cout << first_v<rest_t<collection<int_constant<5>, int_constant<7>>>> << std::endl;
 #+end_src

 #+RESULTS:
 : 7

Otra función que es bastante común es ~range~. Recibe un entero y devuelve una colección con todos los números no negativos menores que él.

#+begin_src C++ :exports both :eval never-export :results output :includes '(<iostream> </home/hectarea/lispylambda/posts/C++/prueba.h>)
template<typename N, typename I>
struct range_aux {};

template<int k>
struct range_aux<int_constant<k>,int_constant<k>> : collection<> {};

template<int n, int i>
struct range_aux<int_constant<n>, int_constant<i>>
  : cons<int_constant<n>, typename range_aux<int_constant<n+1>, int_constant<i>>::type> {};

template<typename I>
struct range : range_aux<int_constant<0>, I> {};

canonize(range);
 #+end_src

Ahora podemos, por ejemplo, calcular la suma de los 100 primeros números naturales:

#+begin_src C++ :exports both :eval never-export :results output :includes '(<iostream> </home/hectarea/lispylambda/posts/C++/prueba.h>)
std::cout << sum_v<range_t<int_constant<101>>> << std::endl;
 #+end_src

 #+RESULTS:
 : 5050

Otra función más: ~length~. Creo que no es necesario ni explicar qué va a hacer.

#+begin_src C++ :exports both :eval never-export :results output :includes '(<iostream> </home/hectarea/lispylambda/posts/C++/prueba.h>)
template<typename C>
struct length {};

template<>
struct length<collection<>> : int_constant<0> {};

template<typename C, typename... CS>
struct length<collection<C,CS...>> : add1<typename length<collection<CS...>>::type> {};

canonize(length);
 #+end_src

Podemos comprobar su validez con ~range~:

#+begin_src C++ :exports both :eval never-export :results output :includes '(<iostream> </home/hectarea/lispylambda/posts/C++/prueba.h>)
std::cout << length_v<range_t<int_constant<5>>> << std::endl;
 #+end_src

 #+RESULTS:
 : 5

Perfecto.

A partir de aquí se vienen un poco de curvas. Vamos a definir las funciones ~zip~ y ~map~. El problema está en que ~map~ es fácil de implementar si tenemos ~zip~, pero ~zip~ es fácil de implementar si tienemos ~map~. Así que de alguna manera tenemos que ensuciarnos las manos con recursividad en alguna de las funciones. 

Empezaremos con una versión simplificada de ~map~: ~map_single~. Esta función crea una colección con los resultados de aplicar una función recibida a cada uno de los elementos de una colección recibida.

#+begin_src C++ :exports both :eval never-export :results output :includes '(<iostream> </home/hectarea/lispylambda/posts/C++/prueba.h>)
template<typename F, typename C>
struct map_single {};

template<typename F, typename... CS>
struct map_single<F, collection<>> : collection<> {};

template<typename F, typename C, typename... CS>
struct map_single<F, collection<C,CS..>>
  : cons<funcall_t<F,C>, typename map_single<F, collection<CS...>>::type> {};

canonize(map_single);
 #+end_src

Vamos a hacer una pequeña prueba:

#+begin_src C++ :exports both :eval never-export :results output :includes '(<iostream> </home/hectarea/lispylambda/posts/C++/prueba.h>)
std::cout << sum_v<map_single_t<add1_f, range_t<int_constant<3>>>> << std::endl;
 #+end_src

 #+RESULTS:
 : 6

Perfecto. La llamada a ~range_t<int_constant<3>>~ ha creado el tipo ~collection<int_constant<0>,int_constant<1>,int_constant<2>>~. Al sumarle ~1~ a cada uno de estos elementos con ~add1_f~ conseguimos una colección con los números ~1~, ~2~ y ~3~. Y la suma de estos 3 números es, efectivamente, ~6~.

Vamos a necesitar también la función ~and_bool~. En los primeros capítulos definimos ~or_bool~ que aplicaba la operación lógica ~or~ sobre dos ~bool_constant~. Vamos a generalizar estas funciones para que acepten una cantidad variable de argumentos.

#+begin_src C++ :exports both :eval never-export :results output :includes '(<iostream> </home/hectarea/lispylambda/posts/C++/prueba.h>)
template<typename... BS>
struct and_bool {};

template<>
struct and_bool<> : bool_constant<true> {};

template<typename B>
struct and_bool<B> : B {};

template<bool a, bool b, typename... BS>
struct and_bool<bool_constant<a>, bool_constant<b>, BS...>
  : and_bool<bool_constant<a && b>, BS...> {};

canonize(and_bool);
 #+end_src

Con esto ya tenemos herramientas para crear ~zip~ de manera relativamente cómoda. Esta función recibe una cantidad variable de colecciones y creará una colección de colecciones. La primera colección contiene los primeros elementos de las colecciones recibidas. La segunda, los segundos elementos. Y así, hasta que alguna colección recibida no tenga más elementos. La complicación de esta función reside principalmente en ir comprobando que alguna de las colecciones se quede vacía para terminar la evaluación. Para ello, usamos una función ~zip_aux~ que recibe además un booleano indicando si debemos terminar o no, es decir, si alguna colección ya no tiene elementos.

#+begin_src C++ :exports both :eval never-export :results output :includes '(<iostream> </home/hectarea/lispylambda/posts/C++/prueba.h>)
template<bool stop, typename... CS>
struct zip_aux {};
 #+end_src

Si debemos parar devolvemos una colección vacía.

#+begin_src C++ :exports both :eval never-export :results output :includes '(<iostream> </home/hectarea/lispylambda/posts/C++/prueba.h>)
template<typename... CS>
struct zip_aux<false, CS...> : collection<> {};
 #+end_src

Si debemos seguir, necesitamos calcular varias cosas. 

Primero, debemos determinar si en la siguiente llamada deberemos continuar o no. Para ello, para cada una de las colecciones debemos eliminar el primer elemento y comprobar que la colección resultante está vacía. Si alguna de esas colecciones es vacía entonces debemos indicar con el valor ~true~ que debemos parar. Parecen muchas cosas, pero tenemos bastantes herramientas. Para poder eliminar el primer elemento de una colección usamos ~rest~. Y si queremos hacerlo para cada colección basta usar ~map_single~. Es decir, si ~CS...~ son nuestras colecciones, entonces basta evaluar ~map_single_t<rest_f,collection<CS...>>~. Ahora queremos saber si alguna de las colecciones que está dentro de la colección devuelta por la anterior llamada está vacía. Para saber si una colección está vacía usamos ~is_empty~. Si queremos usar la función para cada colección usamos de nuevo ~map_single_t~. La llamada a realizar, por ahora, sería ~map_single_t<is_empty_f,map_single_t<rest_f,collection<CS...>>>~. Esto nos devuelve una colección de ~bool_constant~. Si alguno de estos booleanos es ~false~, entonces devolvemos ~false~. Eso es aplicar la operación lógica ~and~. Y aquí entra ~and_bool~. Pero ~and_bool~ acepta una cantidad variable de booleanos, no una colección. No pasa nada, porque podemos usar ~apply~. Con todo esto la llamada final sería ~apply_v<and_bool_f,map_single_t<is_empty_f,map_single_t<rest_f,collection<CS...>>>>~. 

En segundo lugar, debemos coger los primeros elementos de cada colección e introducirlos en una nueva. Como ~CS...~ son las colecciones que hemos recibido habría que evaluar los siguiente: ~collection<first_t<CS>...>~. Sencillo.

Por último, la parte de recursividad. Debemos llamar a la propia función ~zip~ con las colecciones recibidas habiendo eliminado el primer elemento. La llamada sería ~zip_aux<'el booleano de antes', rest_t<CS>...>~. 

Ahora, para juntarlo todo, debemos coger la colección obtenida del segundo punto y añadirlo como primer elemento a la colección de colecciones obtenida por el tercer punto. 

#+begin_src C++ :exports both :eval never-export :results output :includes '(<iostream> </home/hectarea/lispylambda/posts/C++/prueba.h>)
template<typename... CS>
struct zip_aux<true, CS...> 
  : cons<collection<first_t<CS>...>, 
         typename zip_aux<apply_v<and_bool_f,map_single_t<is_empty_f,map_single_t<rest_f,collection<CS...>>>>,
                          rest_t<CS>...>::type> {};
 #+end_src

Ya solo queda crear ~zip~ usando ~zip_aux~. Todo el código quedaría así:

#+begin_src C++ :exports both :eval never-export :results output :includes '(<iostream> </home/hectarea/lispylambda/posts/C++/prueba.h>)
template<bool stop, typename... CS>
struct zip_aux {};

template<typename... CS>
struct zip_aux<false, CS...> : collection<> {};

template<typename... CS>
struct zip_aux<true, CS...> 
  : cons<collection<first_t<CS>...>, 
         typename zip_aux<apply_v<and_bool_f,map_single_t<is_empty_f,map_single_t<rest_f,collection<CS...>>>>,
                          rest_t<CS>...>::type> {};

template<typename... CS>
struct zip : zip_aux<apply_v<and_bool_f,map_single_t<is_empty_f,CS...>>,
                     CS...> {};

canonize(zip);
 #+end_src

Observa que para llamar a ~zip_aux~ en ~zip~ tenemos que comprobar también si alguna de las colecciones está vacía. Al menos no tenemos que eliminar el elemento inicial, por lo que la llamada es más sencilla.

#+begin_src C++ :exports both :eval never-export :results output :includes '(<iostream> </home/hectarea/lispylambda/posts/C++/prueba.h>)
debug<zip_t<range_t<int_constant<3>>, range_t<int_constant<3>>>>::type;
 #+end_src

#+begin_src C++ :exports both :eval never-export :results output :includes '(<iostream> </home/hectarea/lispylambda/posts/C++/prueba.h>)
error: ‘type’ is not a member of 
‘debug<collection<
      collection<std::integral_constant<int, 0>, std::integral_constant<int, 0> >,                    
      collection<std::integral_constant<int, 1>, std::integral_constant<int, 1> >, 
      collection<std::integral_constant<int, 2>, std::integral_constant<int, 2> > > >
 #+end_src

Perfecto. 

Ahora ya podemos definir la función ~map~. Esta función recibe una función y una cantidad variable de colecciones. Todos los primeros elementos de cada colección son pasados a la función recibida generando un valor que se almacena en una nueva colección. Y lo mismo ocurre para todos los segundos elementos, todos los terceros, etc. La forma de agrupar cada uno de esos elementos es sencilla ahora que disponemos de la función ~zip~. Luego, basta aplicar la función con los elementos de cada colección devuelta por ~zip~. Para esta última parte definiremos una función auxiliar ~map_aux~.

#+begin_src C++ :exports both :eval never-export :results output :includes '(<iostream> </home/hectarea/lispylambda/posts/C++/prueba.h>)
template<typename F, typename C>
struct map_aux {};

template<typename F, typename... CS>
struct map_aux<F, collection<CS...>> : collection<apply_t<F,CS>...> {};

template<typename F, typename... CS>
struct map : map_aux<F, zip_t<CS...>> {};

canonize(map);
 #+end_src

#+begin_src C++ :exports both :eval never-export :results output :includes '(<iostream> </home/hectarea/lispylambda/posts/C++/prueba.h>)
std::cout << apply_v<add_f,map_t<add_f, range_t<int_constant<3>>, range_t<int_constant<3>>>> << std::endl;
 #+end_src

 #+RESULTS:
 : 6

Lo que acabamos de hacer es generar con ~map_t~ una coleccion con 3 elementos. Cada elemento tiene la suma de los dos primeros, dos segundos y dos terceros elementos de cada ~range_t~. Es decir, devuelve la colección con los elementos ~0~, ~2~ y ~4~ que son el resultado de ~0+0~, ~1+1~ y ~2+2~. Luego se aplica la función de suma sobre esta colección obteniendo así el valor ~6~.

Espero que no te duela la cabeza... Porque todo esto ha sido sencillo, ¿verdad? Además, los templates son bastante legibles... Bueno, mira el lado positivo, con ~canonize~ tenemos que escribir menos.

* Curryficación

Aún recuerdo cuando, en mi último año de universidad, nuestra profesora de programación nos explicó la curryficación. No entendí nada. Y no fue su culpa, a ella la considero una de las mejores profesoras que podías encontrar en la facultad de informática. Fue con algunos ejemplos en Haskell cuando empecé a entender qué era la curryficación. Y puedo decir que fue el primer concepto de programación que me pareció magia. 

Todos sabemos lo que es una función. Un trozo de código parametrizado por unos argumentos. Para ejecutar una función debemos darle el número correcto de argumentos, y si no, pues se genera un error, normalmente de compilación. Pero en Haskell no ocurría lo mismo. Si a una función le das menos argumentos de los que la función debía recibir, no se generaba nigún error. En su lugar, se devolvía una nueva función. Una función que debía recibir el resto de argumentos que la función original no recibió en primer lugar. Cuando a esta nueva función le das todos los argumentos, entonces se ejecutaba la función original. Cuando una función se comporta de esta manera decimos que la función está *curryficada*. La función devuelta podría o no estar también curryficada.

El ejemplo más sencillo para entender la curryficación trata de usar la función ~suma~. La función ~suma~ suele recibir dos argumentos, ni uno más ni uno menos. 

#+begin_src C++
suma(3, 4);
#+end_src

Esta llamada daría el valor ~7~. Imaginemos ahora que intentamos ejecutar la misma función con sólo el argumento ~3~.

#+begin_src C++
nuevaFuncion = suma(3);
#+end_src

Esto devuelve una ~nuevaFuncion~ que requierirá sólo un argumento. Al recibir ese nuevo argumento, ejecutará la función original con el nuevo argumento y los que ya recibió anteriormente dicha función original.

#+begin_src C++
nuevaFuncion(4);
#+end_src

Esta llamada volvería a darnos el valor ~7~. 

Por tanto, podemos observar que la función devuelta por ~suma(3)~ es aquella que suma ~3~ al valor que reciba como parámetro.

El gran potencial de la curryficación reside en poder crear funciones al vuelo. Y es que es tan fácil crear una función como lo es pasarle menos argumentos a otra.

Las funciones que hemos visto hasta ahora en T++ no está curryficadas. Si intentamos pasar un número de argumentos insuficiente se generará un error de compilación. Por tanto, lo que debemos hacer es curryficarlas. La idea es muy sencilla, y es casi igual a lo que hicimos con ~function~. Recordemos cómo se implementó ~function~:

#+begin_src C++
  template<template<typename...> typename F>
  struct function{
	using type = function;

	template<typename... A>
	using call = typename F<A...>::type;
  };
#+end_src

El template ~function~ recibía un tipo templatizado ~F~ y es uno de sus miembros, ~call~, el que debía recibir los argumentos de dicho tipo. Al usar call, se 'ejecutaba' ~F~. 

Para crear una función curryficada usaremos ~curry~. Y será muy parecida. La única diferencia es que, inicialmente, además de recibir un tipo templatizado también recibirá parte de los argumentos que necesita. Luego, el miembro ~call~ recibirá el resto:

#+begin_src C++
  template<template<typename...> typename F, typename... AS>
  struct curry{
	using type = curry;

	template<typename... BS>
	using call = typename F<AS...,BS...>::type;
  };
#+end_src

Veamos un ejemplo de cómo se usaría con la función ~add~. Vamos a crear una función que suma el valor ~3~. Para ello, le pasamos el argumento ~3~ a ~add~ mediante el uso de ~curry~:

#+begin_src C++ :exports both :eval never-export :results output :includes '(<iostream> </home/hectarea/lispylambda/posts/C++/prueba.h>)
using add3_f = curry<add, int_constant<3>>;
std::cout << funcall_v<add3_f, int_constant<4>> << std::endl;
#+end_src

#+RESULTS:
: 7

Al pasarle el valor 3 a la función curryficada, recibimos una nueva función que llamamos ~add3_f~. Luego la ejecutamos mediante ~funcall_v~ pasándole el argumento ~4~. 

Esto ya es más cómodo que crear una nueva función como las que hemos creado hasta ahora. E incluso podemos hacerlo mejor. Con ~curry~ realmente no estamos curryficando nada. Lo ideal sería tener algo como ~add_c~ que represente de verdad una función curryficada. De hecho, crear esa función curryficada es sencillo:

#+begin_src C++
template<typename A>
using add_c = curry<add, A>;
#+end_src

#+begin_src C++ :exports both :eval never-export :results output :includes '(<iostream> </home/hectarea/lispylambda/posts/C++/prueba.h>)
using add3_f = add_c<int_constant<3>>;
std::cout << funcall_v<add3_f, int_constant<4>> << std::endl;
#+end_src

#+RESULTS:
: 7

Si tuviésemos una forma de curryficar todas las funciones... 

¡¡ ~canonize~!!

Vamos a añadir la curryficación a ~canonize~, de esta forma todas nuestras funciones tendrán una versión curryficada:

#+begin_src C++
#define canonize(name)                                  \
  template<typename... TS>                              \
  using name##_t = typename name<TS...> ::type;         \
                                                        \
  template<typename... TS>                              \
  static constexpr auto name##_v = name<TS...> ::value; \
                                                        \
  using name##_f = function<name>;                      \
                                                        \
  template<typename... TS>                              \
  using name##_c = curry<name, TS...>;
#+end_src
 
Vamos a probar:

#+begin_src C++ :exports both :eval never-export :results output :includes '(<iostream> </home/hectarea/lispylambda/posts/C++/prueba.h>)
using first_five = range_t<int_constant<5>>;
using next_first_five = map_t<add_c<int_constant<10>>, first_five>;  
std::cout << sum_v<next_first_five> << std::endl;
#+end_src

#+RESULTS:
: 60

Vayamos paso a paso. En la primera línea se crea la colección ~{0,1,2,3,4}~. En la siguiente línea sumamos ~10~ a cada uno de los elementos de la colección. Observa que sin la curryficación tendríamos que haber definido una función llamada ~add10~ o algo parecido. Con esta segunda línea se genera la colección ~{10,11,12,13,14}~. Y por último sumamos los valores de la colección: ~10+11+12+13+14 = 60~.


* If else
¿Ahora? ¿A estas alturas vemos el ~if-else~? Pues sí, y para entender por qué no lo hemos visto antes vamos a intentar crear la función de fibonacci. Recuerda que esta función recibe un índice y devuelve el valor con dicho índice de la sucesión de fibonacci. Los dos primeros valores de dicha sucesión son ~0~ y ~1~. Los siguientes, son la suma de los dos anteriores. Así, si recibimos un ~0~, devolvemos un ~0~. Si recibimos un ~2~, devolvemos un ~1~ (~0+1~). Y si recibimos un ~3~ devolvemos un ~2~ (~1+1~).

El algoritmo en C++ sería el siguiente:

#+begin_src C++
int fibo(int n){
  if (n == 0) 
    return 0;
  else if (n == 1)
    return 1;
  else
    return fibo(n-1) + fibo(n-2);
}
#+end_src 

Para mantener las cosas simples, obviamos el hecho de que pasar un valor negativo supondría el fin del mundo.

Para crear la función T++ vamos a intentar crear algo como un ~if-else~. Recibe ~3~ argumentos, un ~bool_constant~ (la condición) y dos valores más (~then~ y ~else~). Si el booleano es ~true~ devolvemos el segundo argumento. Si el booleano es ~false~, devolvemos el tercero.

Como ~if~ ya está reservado para C++, usaremos ~branch~:

#+begin_src C++
template<typename C, typename T, typename E>
struct branch {};

template<typename T, typename E>
struct branch<bool_constant<true>,T,E> : T {};

template<typename T, typename E>
struct branch<bool_constant<false>,T,E> : E {};

canonize(branch);
#+end_src

Vamos a realizar una pequeña prueba:

#+begin_src C++ :exports both :eval never-export :results output :includes '(<iostream> </home/hectarea/lispylambda/posts/C++/prueba.h>)
std::cout << branch_v<bool_constant<true>, int_constant<5>, int_constant<10>> << std::endl;
#+end_src

#+RESULTS:
: 5

¡Perfecto! Ahora podemos crear la función de fibonacci con el algoritmo descrito anteriormente:

#+begin_src C++ :exports both :eval never-export :results output :includes '(<iostream> </home/hectarea/lispylambda/posts/C++/prueba.h>)
template<typename N>
struct fibonacci : branch<eql_t<N, int_constant<0>>, 
                          int_constant<0>,
                          branch_t<eql_t<N, int_constant<1>>,
                                   int_constant<1>,
                                   add_t<typename fibonacci<sub1_t<N>>::type,
                                         typename fibonacci<sub1_t<sub1_t<N>>>::type>>> {};

canonize(fibonacci);
#+end_src

Veamos a ver si funciona:

#+begin_src C++ :exports both :eval never-export :results output :includes '(<iostream> </home/hectarea/lispylambda/posts/C++/prueba.h>)
std::cout << fibonacci_v<int_constant<0>> << std::endl;
#+end_src

#+begin_src
In instantiation of ‘struct int_constant<-450>’: fatal error: template instantiation depth exceeds maximum of 900 (use ‘-ftemplate-depth=’ to increase the maximum)
#+end_src

¡¿Pero qué...?! Analicemos lo que está pasando. Cuando utilizamos ~branch~, sus argumentos debene de evaluarse antes de evaluar ~branch~ por sí misma. Eso quiere decir que el segundo ~branch~ tiene que evaluarse antes. Y por la misma razón tiene que evaluarse antes la expresión ~add_t<fibonacci<sub1_t<N>>, fibonacci<sub1_t<sub1_t<N>>>>~. Como ~add_t~ funciona de la misma manera deben evaluarse sus argumentos. En concreto se evaluará ~fibonacci<sub1_t<N>>::type~. Es decir, para evaluar ~fibonacci<N>~ se debe evaluar antes ~fibonacci<sub1_t<N>>~. Pero para evaluar ~fibonacci<sub1_t<N>>~ deberemos evaluar ~fibonacci<sub1_t<sub1_t<N>>>~ y para ello se deberá evaluar ~fibonacci<sub1_t<sub1_t<sub1_t<N>>>>~ y para deberá evaluarse... ¡Entramos en un bucle infinito!

El problema radica en cómo se ha definido ~branch~. Al tener que evaluarse cada una de las ramas antes de evaluar la propia expresión ~branch~ cabe la posibilidad de entrar en bucles infinitos. ¿La solución? Retrasar la evaluación de los argumentos. Y la idea es muy simple: En lugar de intentar pasar el valor que devolvería la rama correspondiente, pasaremos una función que devolverá el valor.

Vamos a modificar ~branch~ para que el segundo y tercer argumento (~then~ y ~else~) sean una función que evaluaremos con ~funcall~.

#+begin_src C++
template<typename C, typename T, typename E>
struct branch {};

template<typename T, typename E>
struct branch<bool_constant<true>,T,E> : funcall<T> {};

template<typename T, typename E>
struct branch<bool_constant<false>,T,E> : funcall<E> {};

canonize(branch);
#+end_src

Vale, la idea está bien. Pero en la práctica, ¿cómo lo usamos? Al tener que pasar funciones, como por ejemplo ~add_f~, tendríamos que definir nuevas funciones cada vez que queramos usar ~branch~. Bueno, sí. Pero en el capítulo anterior hemos visto una forma de crear funciones al vuelo: la *curryficación*.

Pero detengámonos un poco más para explicar qué es lo que vamos a hacer. Observa en la nueva definición de ~branch~ que usamos ~funcall~. Recuerda que ~funcall~ debía recibir una función (en este caso ~T~ o ~E~) y los argumentos a pasar a dicha función. Sin embargo, en ~branch~ no se está pasando ningún argumento a parte de la función a ejecutar. Esto es porque debemos pasar funciones que no reciben ningún argumento. O dicho de otra forma, deben recibir cero argumentos.

Así que la siguiente pregunta es: ¿cómo conseguimos crear funciones que reciben cero argumentos? ¿y cómo lo hacemos con las funciones curryficadas?

Recuerda que una función curryficada normalmente recibe menos argumentos de los necesarios para así devolver una nueva función que debe recibir el resto. Vamos a recordar su implementación:

#+begin_src C++
template<template<typename...> typename F, typename... AS>
struct curry{
  using type = curry;

  template<typename... BS>
  using call = typename F<AS...,BS...>::type;
};
#+end_src

Por la forma en la que se ha implementado la curryficación, ¿qué ocurre si a una función curryficada le pasamos todos sus argumentos? La respuesta es que no se ejecuta la función, sino que se crea una nueva función que recibe el resto de los argumentos, es decir, cero argumentos. 

Esto quiere decir que cada vez que usemos ~branch~, en lugar de ejecutar las funciones como hacíamos normalmente, usaremos funciones curryficadas pasando todos los argumentos. Vamos a cambiar la definición de fibonacci:

#+begin_src C++
std::cout << branch_v<bool_constant<true>, int_constant<5>, int_constant<10>> << std::endl;
#+end_src

En lugar de ~int_constant~, usamos ahora su versión curryficada ~int_constant_c~:

#+begin_src C++ :exports both :eval never-export :results output :includes '(<iostream> </home/hectarea/lispylambda/posts/C++/prueba.h>)
std::cout << branch_v<bool_constant<true>, int_constant_c<5>, int_constant_c<10>> << std::endl;
#+end_src

#+RESULTS:
