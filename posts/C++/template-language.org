#+TITLE: T++: El lenguaje oculto tras los Templates
#+date:<2023-07-30 do.>

Te propongo lo siguiente: Vamos a aprender un lenguaje de programación nuevo. Lo llamaremos *T++*. Es un lenguaje funcional puro, pero no te preocupes, iremos poco a poco si nunca te has enfrentado con algo así.

T++ es un lenguaje que se usa sobre C++. Por ello, podemos crear una función ~main~ común y corriente para poder comprobar el código que vayamos haciendo. Además, incluiremos una librería indispensable para poder usar T++: *type_traits*.

#+begin_src C++
  #include <iostream>
  #include <type_traits>

  // Aqui declararemos todas las funciones

  int main(){

	  // Aquí porbaremos las funciones

	  return 0;
  }
#+end_src

* Tipos de datos primitivos
En T++ los tipos de datos primitivos son estructuras creadas a partir de la expresión ~std::integral_constant~. Esta expresión recibe un tipo de C++ y un valor de dicho tipo. Entre los tipos permitidos se encuentran los tipos integrales, los punteros o incluso las referencias.

#+begin_quote
A partir de C++20 tenemos incluso tipos de coma flotante.
#+end_quote

 Pero empecemos por lo sencillo. Los tipos integrales incluyen los enteros, booleanos o caracteres, entre otros. En T++, para definir un tipo integral ya hemos dicho que debemos usar ~std::integral_constant<type,value>~. Por ejemplo, si queremos crear el entero ~5~ en T++, usamos la expresión ~std::integral_constant<int,5>~. Es más, con ~using~ podemos definir aliases para estos valores de T++.

 #+begin_src C++ :exports both :eval never-export :results output :includes '(<iostream> "\"/home/hector/lispylambda/posts/C++/prueba.h\"")
   using cinco = std::integral_constant<int,5>;
 #+end_src 

Pero ojo, esto es un tipo en C++ que representa al valor ~5~. Si queremos *extraer* el valor que se encuentra en su interior, debemos añadir ~::value~.

 #+begin_src C++ :exports both :eval never-export :results output :includes '(<iostream> "\"/home/hector/lispylambda/posts/C++/prueba.h\"")
   std::cout << cinco::value << std::endl;
 #+end_src

 #+RESULTS:
 : 5

Podemos hacer lo mismo con un booleano:

 #+begin_src C++ :exports both :eval never-export :results output :includes '(<iostream> "\"/home/hector/lispylambda/posts/C++/prueba.h\"")
   using myFalse = std::integral_constant<bool,false>;

   std::cout << myFalse::value << std::endl;
 #+end_src

 #+RESULTS:
 : 0

Pero observemos cómo hemos construido estos valores. Hemos usado ~std::integral_constant~. Pero, ¿qué es esta expresión en T++? Pues como veremos a continuación, es una función de T++. Aunque también se conocen como meta-funciones en C++.
 
* Funciones
Yendo al grano, una función en T++ va a ser una estructura (templatizada o no) que contenga al menos un atributo ~type~ y, opcionalmente, un atributo ~value~.

Nosotros ya hemos usado una función, ~std::integral_constant~. De hecho, podríamos haber creado esta función de la siguiente manera:

 #+begin_src C++ :exports both :eval never-export :results output :includes '(<iostream> "\"/home/hector/lispylambda/posts/C++/prueba.h\"")
   template<typename T, T v>
   struct integral_constant{
	   using type = integral_constant;
	   static constexpr T value = v;
   };
 #+end_src

Para empezar nuestra aventura con las funciones, vamos a crear una que nos permita crear un entero de T++ a partir de un entero de C++. Sin embargo, vamos a hacerlo un poco diferente a la posible ~integral_constant~ que acabamos de hacer. Recuerda que los atributos como ~type~ o ~value~ se pueden heredar. Por tanto sólo tenemos que heredar del tipo correcto para terminar hacer nuestra función.

 #+begin_src C++ :exports both :eval never-export :results output :includes '(<iostream> "\"/home/hector/lispylambda/posts/C++/prueba.h\"")
   template<int k>
   struct int_constant : std::integral_constant<int,k>{};
 #+end_src

 Y listo! Si no te fías, recuerda la definición de función en T++. Hemos hecho una estructura templatizada que recibe un entero. Como heredamos de la estructura ~std::integral_constant<int,k>~, conseguimos gratuitamente todos sus atributos, incluidos el atributo ~type~ y su atributo ~value~.

 #+begin_src C++ :exports both :eval never-export :results output :includes '(<iostream> "\"/home/hector/lispylambda/posts/C++/prueba.h\"")
   std::cout << int_constant<42>::value << std::endl;
 #+end_src

 #+RESULTS:
 : 42

Al usar la expresión ~int_constant<42>~ estamos llamando a la función ~int_constant~ con el parámetro ~42~. Además accedemos a su valor usando el atributo ~value~.

Usar el atributo ~value~ es tan común que para cada función de T++ suele crearse otro template que accede directamente a dicho atributo. Hagámos lo mismo.

 #+begin_src C++ :exports both :eval never-export :results output :includes '(<iostream> "\"/home/hector/lispylambda/posts/C++/prueba.h\"")
   template<int k>
   constexpr int int_constant_v = int_constant<k>::value;
 #+end_src

 De esta forma es más cómo acceder a los valores que contienen nuestro valores de T++.
 
 #+begin_src C++ :exports both :eval never-export :results output :includes '(<iostream> "\"/home/hector/lispylambda/posts/C++/prueba.h\"")
   std::cout << int_constant_v<-6> << std::endl;
 #+end_src

 #+RESULTS:
 : -6

 Hasta ahora hemos usado ~value~, pero este era el atributo opcional. El atributo obligatorio es ~type~ y, sin embargo, no lo hemos usado aún. Pues te pido un poco de paciencia, pues será en nuestra siguiente función donde veamos la utilidad de ~type~. Por ahora, debemos quedarnos con que tenemos que crear otro template para cada función de T++ que acceda directamente al atributo ~type~. Hagámoslo con ~int_constant~.

 #+begin_src C++ :exports both :eval never-export :results output :includes '(<iostream> "\"/home/hector/lispylambda/posts/C++/prueba.h\"")
   template<int k>
   using int_constant_t = typename int_constant<k>::type;
 #+end_src

 Observa que este template no es una nueva estructura. Estamos usando ~using~ para crear un alias de ~int_constant<k>::type~.

 Ahora sí, pasemos a la siguiente función. La función de suma de dos enteros. Debemos recibir dos enteros de T++ y devolver su suma.
 
#+begin_src C++ :exports both :eval never-export :results output :includes '(<iostream> "\"/home/hector/lispylambda/posts/C++/prueba.h\"")
  template<typename A, typename B>
  struct add : int_constant<A::value+B::value>{};
 #+end_src

 Recuerda que los valores en T++ siguen siendo tipos en C++, es por eso que el template recibe dos ~typename~. Cada uno debería ser un entero de T++. Y para indicar que devolvemos otro entero hacemos que ~add~ herede de ~int_constant~. De esta forma tendremos sus atributos ~value~ y ~type~. En este caso ~value~ tendrá el valor que recibe ~int_constant~, que es la suma de ~A~ y ~B~.

Siguiendo la tradición, debemos crear los templates ~_v~ y ~_t~:

#+begin_src C++ :exports both :eval never-export :results output :includes '(<iostream> "\"/home/hector/lispylambda/posts/C++/prueba.h\"")
  template<typename A, typename B>
  constexpr int add_v = add<A,B>::value;

  template<typename A, typename B>
  using add_t = add<A,B>::type;
 #+end_src

 Y podemos probar nuestra nueva función para comprobar si es correcta:

 #+begin_src C++ :exports both :eval never-export :results output :includes '(<iostream> "\"/home/hector/lispylambda/posts/C++/prueba.h\"")
   using tres = int_constant<3>;
   using cinco = int_constant<5>;

   std::cout << add_v<tres,cinco> << std::endl;
 #+end_src

 #+RESULTS:
 : 8

 Ahora bien, en el código anterior hay un detalle que hace que no sea del todo correcto. ¿Recuerdas cómo definimos el valor ~5~ en la sección anterior? Lo definimos usando ~std::integral_constant~. Pero ahora hemos usado ~int_constant~. A primera vista parecen lo mismo, porque hemos dicho que ~int_constant~ es una función que devolvía un valor en T++. Pero la realidad es que son tipos diferentes. Y esto puede ocasionar problemas más adelante. Aquí es cuando entra en juego el atributo ~type~. Este atributo es lo que nos permite realmente devolver el valor de una función en T++. En nuestro caso, recuerda que ~int_constant~ se definía heredando de ~std::integral_constant~, por lo que hereda su atributo ~type~, que se inicializaba al propio ~std::integral_constant~. Por tanto, en el ejemplo anterior, lo correcto es usar el atributo ~type~ para crear ~tres~ y ~cinco~. O, equivalentemente, el template que acaba en ~_t~.

 #+begin_src C++ :exports both :eval never-export :results output :includes '(<iostream> "\"/home/hector/lispylambda/posts/C++/prueba.h\"")
   using tres = int_constant_t<3>;
   using cinco = int_constant_t<5>;

   std::cout << add_v<tres,cinco> << std::endl;
 #+end_src

 #+RESULTS:
 : 8

 En este ejemplo ya hemos visto que el cambio no afecta al resultado, pero en ciertas funciones puede suponer el cambio entre la perfección y el desastre.

La función ~add~ definida anteriormente puede ser extendida para aceptar un número variable de argumentos. Usaremos la versión extendida a partir de ahora:

 #+begin_src C++ :exports both :eval never-export :results output :includes '(<iostream> "\"/home/hector/lispylambda/posts/C++/prueba.h\"")
   template<typename... NS>
   struct add : int_constant<0>{};

   template<typename N, typename... NS>
   struct add<N,NS...> : int_constant<N::value+add<NS...>::value> {};

   template<typename... NS>
   constexpr int add_v = add<NS...>::value;

   template<typename... NS>
   using add_t = typename add<NS...>::type;

   using add_f = function<add>;
 #+end_src


* Más funciones
Seguimos viendo ejemplos de algunas funciones un poco más avanzadas. Por ejemplo, estaría bien una función que nos diga si un entero es cero o no. Es decir, debe recibir un entero de T++ (~std::integral_constant~) y devolver un booleano de T++ (otro ~std::integral_constant~).

Para esta función es necesario usar las especializaciones de templates. Date cuenta que no existe ningún tipo de ~if~ en templates. O mejor dicho, las especializaciones son nuestro ~if~. La idea general es poner lo que es falso en el template general, y lo verdadero en las especializaciones.

 #+begin_src C++ :exports both :eval never-export :results output :includes '(<iostream> "\"/home/hector/lispylambda/posts/C++/prueba.h\"")
   template<typename T>
   struct isZero
	   : bool_constant<false> {};

   template<>
   struct isZero<std::integral_constant<int,0>>
	   : bool_constant<true> {};
 #+end_src

Observa que hemos usado el tipo ~bool_constant~. Es como ~int_constant~, pero para booleanos. Se define de la misma forma.
 
 Creamos también los correspondientes templates ~_v~ y ~_t~.

#+begin_src C++ :exports both :eval never-export :results output :includes '(<iostream> "\"/home/hector/lispylambda/posts/C++/prueba.h\"")
  template<typename T>
  constexpr bool isZero_v = isZero<T>::value;

  template<typename T>
  using isZero_t = typename isZero<T>::type;
 #+end_src

 Vamos a probar la función.

#+begin_src C++ :exports both :eval never-export :results output :includes '(<iostream> "\"/home/hector/lispylambda/posts/C++/prueba.h\"")
  std::cout << isZero_v<int_constant<0>> << std::endl;
 #+end_src

 #+RESULTS:
 : 0
 
 Le pasamos a la función el valor ~0~ y la función nos devuelve verdadero. Espera... ha devuelto falso. ¡Claro! Recuerda lo que dijimos sobre ~type~. Le estamos pasando a ~isZero~ el tipo ~int_constant~ cuando realmente le tenemos que pasar ~std::integral_constant~. Basta aquí cambiar ~int_constant~ por ~int_constant_t~.

 #+begin_src C++ :exports both :eval never-export :results output :includes '(<iostream> "\"/home/hector/lispylambda/posts/C++/prueba.h\"")
  std::cout << isZero_v<int_constant_t<0>> << std::endl;
 #+end_src

 #+RESULTS:
 : 1

Observa de nuevo la definición de ~isZero~. La especialización se realiza sobre el tipo ~integral_constant~. Es por ello que con ~int_constant~ se devolvía el valor falso. Lo mismo ocurriría si utilizásemos ~add~ en lugar de ~add_t~.

 #+begin_src C++ :exports both :eval never-export :results output :includes '(<iostream> "\"/home/hector/lispylambda/posts/C++/prueba.h\"")
   using cuatro = int_constant_t<4>;
   using menosCuatro = int_constant_t<-4>;

   std::cout << isZero_v<add<cuatro,menosCuatro>> << std::endl;

   std::cout << isZero_v<add_t<cuatro,menosCuatro>> << std::endl;
 #+end_src

 #+RESULTS:
 : 0
 : 1

A partir de aquí podemos hacer todas las funciones que manejen valores primitivos de T++ que se nos ocurran. Aquí tienes unas cuantas:

 #+begin_src C++ :exports both :eval never-export :results output :includes '(<iostream> "\"/home/hector/lispylambda/posts/C++/prueba.h\"")
   /// or operator
   template<typename B, typename C>
   struct or_bool : bool_constant<B::value || C::value> {};

   template<typename B, typename C>
   constexpr bool or_bool_v = or_bool<B,C>::value;

   template<typename B, typename C>
   using or_bool_t = typename or_bool<B,C>::type;


   /// not operator
   template<typename B>
   struct not_bool : bool_constant<!B::value> {};

   template<typename B>
   constexpr bool not_bool_v = not_bool<B>::value;

   template<typename B>
   using not_bool_t = typename not_bool<B>::type;


   /// add1
   template<typename N>
   struct add1 : int_constant<N::value + 1> {};

   template<typename N>
   constexpr int add1_v = add1<N>::value;

   template<typename N>
   using add1_t = typename add1<N>::type;


   /// eql
   template<typename N, typename M>
   struct eql : bool_constant<N::value == M::value> {};

   template<typename N, typename M>
   constexpr bool eql_v = eql<N,M>::value;

   template<typename N, typename M>
   using eql_t = typename eql<N,M>::type;


   /// mod operator
   template<typename A, typename B>
   struct mod : int_constant<A::value % B::value> {};

   template<typename A, typename B>
   constexpr int mod_v = mod<A,B>::value;

   template<typename A, typename B>
   using mod_t = typename mod<A,B>::type;


   /// isDivisor
   template<typename D, typename N>
   struct isDivisor : isZero<mod_t<N,D>> {};

   template<typename D, typename N>
   constexpr bool isDivisor_v = isDivisor<D,N>::value;

   template<typename D, typename N>
   using isDivisor_t = typename isDivisor<D,N>::type;


   /// hasDivisors
   template<typename D, typename N>
   struct hasDivisors_aux : or_bool<
							   isDivisor_t<D,N>,
							   typename hasDivisors_aux<add1_t<D>,N>::type> {};

   template<typename N>
   struct hasDivisors_aux<N,N> : bool_constant<false> {};

   template<typename N>
   struct hasDivisors : hasDivisors_aux<int_constant_t<2>,N> {};

   template<typename N>
   constexpr bool hasDivisors_v = hasDivisors<N>::value;

   template<typename N>
   using hasDivisors_t = typename hasDivisors<N>::type;


   /// isPrime
   template<typename N>
   struct isPrime : not_bool<hasDivisors_t<N>> {};

   template<typename N>
   constexpr bool isPrime_v = isPrime<N>::value;

   template<typename N>
   using isPrime_t = typename isPrime<N>::type;


   /// nextPrime
   template<typename N, typename IsPrime>
   struct nextPrimeAux : nextPrimeAux<add1_t<N>,isPrime_t<add1_t<N>>> {};

   template<typename N>
   struct nextPrimeAux<N,bool_constant_t<true>> : N {};

   template<typename N>
   struct nextPrime : nextPrimeAux<add1_t<N>,isPrime_t<add1_t<N>>> {};

   template<typename N>
   constexpr int nextPrime_v = nextPrime<N>::value;

   template<typename N>
   using nextPrime_t = typename nextPrime<N>::type;
 #+end_src

Vale, este código es duro de procesar. Pero nos quedamos al menos con la última, que nos permite obtener el siguiente número primo a partir de uno dado. Vamos a probarla.

 #+begin_src C++ :exports both :eval never-export :results output :includes '(<iostream> "\"/home/hector/lispylambda/posts/C++/prueba.h\"")
   std::cout << nextPrime_v<int_constant_t<13>> << std::endl;
 #+end_src 

 #+RESULTS:
 : 17

Todo esto está muy guay, pero falta algo. Con sólo tipos primitivos no conseguimos mucho. Vamos a ver si podemos crear algo más grande.

* Estructuras de datos
Al igual que existe ~std::integral_constant~, nosotros podemos crear nuevos tipos de datos usando estructuras de C++. Por ejemplo, supongamos que queremos crear en T++ un tipo de dato para representar vectores de dos coordenadas. En primer lugar debemos crear la estructura en C++.

 #+begin_src C++ :exports both :eval never-export :results output :includes '(<iostream> "\"/home/hector/lispylambda/posts/C++/prueba.h\"")
   struct vector{
	   int x;
	   int y;
   };
 #+end_src 

 En segundo lugar, creamos una función en T++ que cree el vector. Manteniendo la nomenclatura de los tipos primitivos, llamaremos a esta función ~vector_constant~.

 #+begin_src C++ :exports both :eval never-export :results output :includes '(<iostream> "\"/home/hector/lispylambda/posts/C++/prueba.h\"")
   template<int x, int y>
   struct vector_constant{
	   static constexpr vector value = {x,y};
	   using type = vector_constant;
   };
 #+end_src

 Observa que esta función tiene el atributo ~type~, que era obligatorio, además del atributo value que es el ~vector~ que hemos declarado justo antes.

Creamos también los templates ~_v~ y ~_t~.

 #+begin_src C++ :exports both :eval never-export :results output :includes '(<iostream> "\"/home/hector/lispylambda/posts/C++/prueba.h\"")
   template<int x, int y>
   constexpr vector vector_constant_v = vector_constant<x,y>::value;

   template<int x, int y>
   using vector_constant_t = typename vector_constant<x,y>::type;
 #+end_src

Para que sea más cómodo mostrar por pantalla un vector, vamos a sobrecargar el operador de extracción ~<<~.

 #+begin_src C++ :exports both :eval never-export :results output :includes '(<iostream> "\"/home/hector/lispylambda/posts/C++/prueba.h\"")
   std::ostream& operator<<(std::ostream& os, const vector& v){
	   os << "(" << v.x << "," << v.y << ")";
   }
 #+end_src

 Vamos a probar a imprimir un vector de T++.

 #+begin_src C++ :exports both :eval never-export :results output :includes '(<iostream> "\"/home/hector/lispylambda/posts/C++/prueba.h\"")
   std::cout << vector_constant_v<5,7> << std::endl;
 #+end_src

 #+RESULTS:
 : (5,7)
 
¡Perfecto!

Obviamente, la primera función que podemos hacer con un vector es el producto escalar de dos vectores. Aunque antes de hacerla creo que sería conveniente crear funciones para acceder a cada uno de los valores de un vector. Es decir, un par de ~getters~.

 #+begin_src C++ :exports both :eval never-export :results output :includes '(<iostream> "\"/home/hector/lispylambda/posts/C++/prueba.h\"")
   template<typename P>
   struct vector_x : int_constant<P::value.x> {};

   template<typename P>
   constexpr int vector_x_v = vector_x<P>::value;

   template<typename P>
   using vector_x_t = typename vector_x<P>::type;


   template<typename P>
   struct vector_y : int_constant<P::value.y> {};

   template<typename P>
   constexpr int vector_y_v = vector_y<P>::value;

   template<typename P>
   using vector_y_t = typename vector_y<P>::type;
 #+end_src

 Definimos también el producto de dos enteros.

 #+begin_src C++ :exports both :eval never-export :results output :includes '(<iostream> "\"/home/hector/lispylambda/posts/C++/prueba.h\"")
   template<typename N, typename M>
   struct mult : int_constant<N::value * M::value> {};

   template<typename N, typename M>
   constexpr int mult_v = mult<N,M>::value;

   template<typename N, typename M>
   using mult_t = typename mult<N,M>::type;
 #+end_src

 Ahora sí, el producto escalar.

 #+begin_src C++ :exports both :eval never-export :results output :includes '(<iostream> "\"/home/hector/lispylambda/posts/C++/prueba.h\"")
   template<typename P, typename Q>
   struct dot_product : add<
						   mult_t<
							   vector_x_t<P>,
							   vector_x_t<Q>>,
						   mult_t<
							   vector_y_t<P>,
							   vector_y_t<Q>>> {};

   template<typename P, typename Q>
   constexpr int dot_product_v = dot_product<P,Q>::value;

   template<typename P, typename Q>
   using dot_product_t = typename dot_product<P,Q>::type;
 #+end_src

Y lo probamos.

 #+begin_src C++ :exports both :eval never-export :results output :includes '(<iostream> "\"/home/hector/lispylambda/posts/C++/prueba.h\"")
   std::cout << dot_product_v<vector_constant_t<2,1>,vector_constant_t<3,5>> << std::endl;
 #+end_src

 #+RESULTS:
 : 11

* Arrays
Los arrays no tienen mucho misterio. Todo se define igual que con las estructuras, excepto algunos detalles. En primer lugar, vamos a utilizar templates variádicos. Es decir, un template que recibe una cantidad arbitraria de parámetros.

 #+begin_src C++ :exports both :eval never-export :results output :includes '(<iostream> "\"/home/hector/lispylambda/posts/C++/prueba.h\"")
   template<int... NS>
   struct int_array{
	   static constexpr int value[] = {NS...};
	   using type = int_array;
   };

   template<int... NS>
   constexpr int int_array_v[] = int_array<NS...>::value;

   template<int... NS>
   using int_array_t = typename int_array<NS...>::type;
 #+end_src

 #+begin_src
   error: initializer fails to determine size of 'int_array_v<NS ...>'
 #+end_src

¡Ups! ¿Qué ha pasado aquí? Parece que el compilador se queja cuando intentamos definir ~int_array_v~. El error nos indica que C++ no es capaz de deducir el tamaño del array. Podríamos intentar usar un puntero a ~value~ para evitar este error.

 #+begin_src C++ :exports both :eval never-export :results output :includes '(<iostream> "\"/home/hector/lispylambda/posts/C++/prueba.h\"")
   template<int... NS>
   constexpr int* int_array_v = int_array<NS...>::value;
 #+end_src

 #+begin_src
   error: invalid conversion from 'const int*' to 'int*'
 #+end_src

 Vale, a ver esto otro:

 #+begin_src C++ :exports both :eval never-export :results output :includes '(<iostream> "\"/home/hector/lispylambda/posts/C++/prueba.h\"")
   template<int... NS>
   constexpr const int* int_array_v = int_array<NS...>::value;
 #+end_src

Vale, esto compila. Vamos a probarlo.

 #+begin_src C++ :exports both :eval never-export :results output :includes '(<iostream> "\"/home/hector/lispylambda/posts/C++/prueba.h\"")
   std::cout << int_array_v<2,4,6>[1] << std::endl;
 #+end_src
 
 #+begin_src
   error: undefined reference to `int_array<2, 4, 6>::value'
 #+end_src

Una última prueba. Creo recordar que los arrays que son ~static constexpr~ tienen que estar definidos (además de estar declarados). Así que vamos a añadir lo siguiente:

 #+begin_src C++ :exports both :eval never-export :results output :includes '(<iostream> "\"/home/hector/lispylambda/posts/C++/prueba.h\"")
   template<int... NS>
   constexpr int int_array<NS...>::value[];
 #+end_src

 Probamos de nuevo...

  #+begin_src C++ :exports both :eval never-export :results output :includes '(<iostream> "\"/home/hector/lispylambda/posts/C++/prueba.h\"")
   std::cout << int_array_v<2,4,6>[1] << std::endl;
 #+end_src

 #+RESULTS:
 : 4
 
 ¡Sí, perfecto!

Antes de continuar, observa que cualquier otro array se definirá de la misma forma pero cambiando el tipo subyacente del array. En ese caso, podemos crear un array genérico en T++.

 #+begin_src C++ :exports both :eval never-export :results output :includes '(<iostream> "\"/home/hector/lispylambda/posts/C++/prueba.h\"")
   template<typename T, T... TS>
   struct integral_array{
	   static constexpr T value[] = {TS...};
	   using type = integral_array;
   };

   template<typename T, T... TS>
   constexpr T integral_array<T, TS...>::value[];

   template <typename T, T... TS>
   constexpr const T* integral_array_v = integral_array<T,TS...>::value;

   template<typename T, T... TS>
   using integral_array_t = typename integral_array<T,TS...>::type;
 #+end_src

Lo probamos:

 #+begin_src C++ :exports both :eval never-export :results output :includes '(<iostream> "\"/home/hector/lispylambda/posts/C++/prueba.h\"")
   std::cout << integral_array_v<int,1,5,10>[2] << std::endl;
 #+end_src

 #+RESULTS:
 : 10

 Podemos ahora redefinir los arrays de enteros a partir de estos arrays genéricos.

 #+begin_src C++ :exports both :eval never-export :results output :includes '(<iostream> "\"/home/hector/lispylambda/posts/C++/prueba.h\"")
   template<int... TS>
   struct int_array : integral_array<int,TS...> {};

   template <int... TS>
   constexpr const int* int_array_v = int_array<TS...>::value;

   template<int... TS>
   using int_array_t = typename int_array<TS...>::type;
 #+end_src

 Vamos a crear la función para poder acceder a los elementos del array. Al igual que con las estructuras, los valores devueltos por estas funciones van a ser tipos primitivos de T++, no de C++. La función para obtener un elemento de un array recibirá el array y un entero de T++ indicando el índice del elemento a devolver. Pero hay aún un problema por resolver. El array es de tipo genérico, así que no sabemos con certeza que tipo debemos devolver. Para ello vamos a crear un nuevo atributo en el array llamado ~value_type~. Este atributo también existe en el tipo ~std::integral_constant~ que hemos usado hasta ahora. Este atributo guarda su tipo subyacente. Para ~std::integral_constant<int,5>~, ~value_type~ vale ~int~. El array quedaría de la siguiente forma:

 #+begin_src C++ :exports both :eval never-export :results output :includes '(<iostream> "\"/home/hector/lispylambda/posts/C++/prueba.h\"")
   template<typename T, T... TS>
   struct integral_array{
	   static constexpr T value[] = {TS...};
	   using type = integral_array;
	   using value_type = T;
   };

   template<typename T, T... TS>
   constexpr T integral_array<T, TS...>::value[];

   template <typename T, T... TS>
   constexpr const T* integral_array_v = integral_array<T,TS...>::value;

   template<typename T, T... TS>
   using integral_array_t = typename integral_array<T,TS...>::type;
 #+end_src

 Ahora sí podemos hacer la función deseada.

 #+begin_src C++ :exports both :eval never-export :results output :includes '(<iostream> "\"/home/hector/lispylambda/posts/C++/prueba.h\"")
   template<typename A, typename N>
   struct aref
	   : std::integral_constant<typename A::value_type,A::value[N::value]> {};

   template<typename A, typename N>
   constexpr typename A::value_type aref_v = aref<A,N>::value;

   template<typename A, typename N>
   using aref_t = typename aref<A,N>::type;
 #+end_src

 La función ~aref~ va a devolver un ~std::integral_constant~. El valor subyacente de este valor tiene que ser el mismo que el del array, por eso usamos ~A::value_type~. Luego, con ~A::value[]~ accedemos a algún valor del array. El índice elegido es ~N::value~, que será un entero de T++.

 Por otro lado, observa cómo se crea ~aref_v~. Como el array es genérico, el único modo de saber el tipo a devolver es accediendo de nuevo a ~A::value_type~.

#+begin_src C++ :exports both :eval never-export :results output :includes '(<iostream> "\"/home/hector/lispylambda/posts/C++/prueba.h\"")
  using miArray = integral_array_t<int,1,1,2,3,5,8>;

  std::cout << aref_v<miArray,int_constant_t<5>> << std::endl;
 #+end_src

 #+RESULTS:
 : 8
 
Por mostrar alguna función usando los arrays, vamos a crear una que calcule la suma de todos los elementos de un array dado. Esta función recibirá un array de enteros, además del número de elementos a sumar.

#+begin_src C++ :exports both :eval never-export :results output :includes '(<iostream> "\"/home/hector/lispylambda/posts/C++/prueba.h\"")
  template<typename A, typename N>
  struct sum_array : add<
						  aref_t<A,sub1_t<N>>,
						  typename sum_array<A,sub1_t<N>>::type> {};

  template<typename A>
  struct sum_array<A,int_constant_t<0>> : int_constant_t<0> {};

  template<typename A, typename N>
  constexpr int sum_array_v = sum_array<A,N>::value;

  template<typename A, typename N>
  using sum_array_t = typename sum_array<A,N>::type;
 #+end_src

Para no complicar mucho la implementación de esta función, los elementos se van sumando de derecha a izquierda. Además, se ha usado la función ~sub1~ que habíamos definido antes. Es equivalente a ~add1~, pero en vez de sumar ~1~, resta ~1~.

Vamos a probarla.

#+begin_src C++ :exports both :eval never-export :results output :includes '(<iostream> "\"/home/hector/lispylambda/posts/C++/prueba.h\"")
  std::cout << sum_array_v<int_array_t<1,4,3>,int_constant_t<3>> << std::endl;
 #+end_src

 #+RESULTS:
 : 8

Perfecto.

Una pregunta obligatoria tras definir los arrays es, ¿y los strings?. Los strings son arrays de caracteres. Así que podríamos definir el tipo ~char_array~ para definir strings.

#+begin_src C++ :exports both :eval never-export :results output :includes '(<iostream> "\"/home/hector/lispylambda/posts/C++/prueba.h\"")
  template<char... cs>
  struct char_array : integral_array<char,cs...> {};

  template <char... cs>
  constexpr const char* char_array_v = char_array<cs...>::value;

  template<char... cs>
  using char_array_t = typename char_array<cs...>::type;
 #+end_src

Pero vamos a reflexionar un poco. Si pensamos en los arrays de caracteres de C o C++, éstos tienen una forma en particular cuando los inicializamos. Estoy hablando del caracter nulo que nos encontramos al final de cada string. Cuando inicializamos un string, C++ añade automáticamente un caracter adicional, el caracter nulo. Nosotros deberíamos hacer lo mismo. Para ello vamos a especializar ~integral_array~ para el tipo ~char~.

#+begin_src C++ :exports both :eval never-export :results output :includes '(<iostream> "\"/home/hector/lispylambda/posts/C++/prueba.h\"")
  template<char... TS>
  struct integral_array<char,TS...>{
	  static constexpr char value[] = {TS...,'\0'};
	  using type = integral_array;
	  using value_type = char;
  };
 #+end_src
 
 A pesar de esto, uno ya puede preveer que crear strings no va a ser muy cómodo, pues tendremos que pasar los caracteres uno a uno.

#+begin_src C++ :exports both :eval never-export :results output :includes '(<iostream> "\"/home/hector/lispylambda/posts/C++/prueba.h\"")
  using holaMundo = char_array_t<'H','o','l','a',' ','m','u','n','d','o','!'>;

  std::cout << holaMundo::value << std::endl;
 #+end_src 

 #+RESULTS:
 : Hola mundo!

Sin embargo, sí podemos crear una función que reciba un puntero a ~char~ y que devuelva un string de T++. Aunque hay que hacer algo de trabajo extra. Las siguientes funciones se salen un poco del objetivo de este trabajo, así que no las explicaré. He dejado un breve comentario indicando para qué sirven.

#+begin_src C++ :exports both :eval never-export :results output :includes '(<iostream> "\"/home/hector/lispylambda/posts/C++/prueba.h\"")
  /// int_collection
  /// define una coleccion de enteros
  template<int... ns>
  struct int_collection {
	  using type = int_collection;
  };

  template<int... ns>
  using int_collection_t = typename int_collection<ns...>::type;


  /// range_collection
  /// devuelve una coleccion de enteros de 0 a n
  template<int n, int... ns>
  struct range_collection_aux : range_collection_aux<n-1,n-1,ns...> {};

  template<int... ns>
  struct range_collection_aux<0,ns...> : int_collection<ns...> {};

  template<int n>
  struct range_collection : range_collection_aux<n> {};

  template<int n>
  using range_collection_t = typename range_collection<n>::type;


  /// aref_str
  /// devuelve el caracter de un string de C++ con indice i
  template<const char* str, int i>
  struct aref_str{
	  static constexpr char value = str[i];
  };

  template<const char* str, int i>
  constexpr char aref_str_v = aref_str<str,i>::value;


  /// length_str
  /// devuelve la longitud de un string de C++
  template<const char* str, int i, bool nullchar>
  struct length_str_aux : length_str_aux<str,i+1,str[i]=='\0'> {};

  template<const char* str, int i>
  struct length_str_aux<str,i,true>{
	  static constexpr int value = i;
  };

  template<const char* str>
  struct length_str : length_str_aux<str,0,str[0]=='\0'> {};

  template<const char* str>
  constexpr int length_str_v = length_str<str>::value;


  /// Crea un string de T++ a partir de uno de C++
  template<const char* str, typename C>
  struct make_string_aux {};

  template<const char* str, int... ns>
  struct make_string_aux<str,int_collection<ns...>> : integral_array<char,aref_str_v<str,ns>...> {};

  template<const char* str>
  struct make_string : make_string_aux<str,range_collection_t<length_str_v<str>>> {};

  template<const char* str>
  constexpr const char* make_string_v = make_string<str>::value;

  template<const char* str>
  using make_string_t = typename make_string<str>::type;
 #+end_src 

Para poder pasar un string como argumento de un template, necesitamos crear el string como una variable global ~constexpr~.

#+begin_src C++ :exports both :eval never-export :results output :includes '(<iostream> "\"/home/hector/lispylambda/posts/C++/prueba.h\"")
  constexpr char holaMundo[] = "Hola mundo!";
 #+end_src

 Lo probamos.

#+begin_src C++ :exports both :eval never-export :results output :includes '(<iostream> "\"/home/hector/lispylambda/posts/C++/prueba.h\"")
  std::cout << make_string_v<holaMundo> << std::endl;
 #+end_src

 #+RESULTS:
 : Hola mundo!
 
Y por si no convence mucho el ejemplo, vamos a utilizar la función ~aref~.

#+begin_src C++ :exports both :eval never-export :results output :includes '(<iostream> "\"/home/hector/lispylambda/posts/C++/prueba.h\"")
  std::cout << aref_v<make_string_t<holaMundo>,int_constant_t<5>> << std::endl;
 #+end_src

 #+RESULTS:
 : m

 Una última reflexión para cerrar esta sección, es si podríamos crear arrays de estructuras. Quizás sea posible, pero recuerda que en nuestro ejemplo la estructura debía recibir varios argumentos. En concreto, recibirá tantos argumentos como miembros tenga la estructura. En un array de estructuras, tendríamos que pasar todos los argumentos al mismo tiempo para todas las estructuras del array. Sólo de pensarlo me dan escalofríos. Mejor dejarlo aquí y continuar con otros tipos de contenedores que nos serán más útiles.

* Colecciones
Hasta ahora nos hemos centrado en valores primitivos y arrays de estos valores. Pero podemos crear también contenedores de tipos. Uno de estos contenedores los llamaremos colecciones. Aquí va la definición.

#+begin_src C++ :exports both :eval never-export :results output :includes '(<iostream> "\"/home/hector/lispylambda/posts/C++/prueba.h\"")
  template<typename... TS>
  struct collection{
	  using type = collection;
  };

  template<typename... TS>
  using collection_t = typename collection<TS...>::type;
 #+end_src

 Este template recibe una cantidad arbitraria de tipos y... no hace nada con ellos. El simple hecho de estar en la lista de argumentos nos permite 'almacenarlos'. Observa además que en este caso no tiene sentido un atributo ~value~, pues todos los argumentos son tipos que no tienen por qué representar ningún valor, ya sea numérico o de cualquier otro tipo.
 
Como ejemplo podemos crear una función que nos diga si una colección está o no vacía.

#+begin_src C++ :exports both :eval never-export :results output :includes '(<iostream> "\"/home/hector/lispylambda/posts/C++/prueba.h\"")
  template<typename C>
  struct is_empty {};

  template<typename T, typename... TS>
  struct is_empty<collection<T,TS...>> : bool_constant<false> {};

  template<typename... TS>
  struct is_empty<collection<TS...>> : bool_constant<true> {};

  template<typename C>
  constexpr bool is_empty_v = is_empty<C>::value;

  template<typename C>
  using is_empty_t = typename is_empty<C>::type;
 #+end_src

Observa que, como otras funciones que hemos implementado, se usa la especialización de templates. Pues fíjate en el caso general, es decir, la primera de todas. Es un struct vacío, no hereda de nadie ni tiene atributos. Al hacer esto, estamos forzando a que se genere un error si alguien usa esta función si no proporciona una colección como argumento.

Probamos la función.

#+begin_src C++ :exports both :eval never-export :results output :includes '(<iostream> "\"/home/hector/lispylambda/posts/C++/prueba.h\"")
  std::cout << is_empty_v<collection_t<>> << std::endl;
  std::cout << is_empty_v<collection_t<int,float,char>> << std::endl;
 #+end_src

 #+RESULTS:
 : 1
 : 0

Concatenar colecciones también es muy sencillo.

#+begin_src C++ :exports both :eval never-export :results output :includes '(<iostream> "\"/home/hector/lispylambda/posts/C++/prueba.h\"")
  template<typename C, typename D>
  struct concatenate {};

  template<typename... CS, typename... DS>
  struct concatenate<collection<CS...>,collection<DS...>> : collection<CS...,DS...> {};

  template<typename C,typename D>
  using concatenate_t = typename concatenate<C,D>::type;
 #+end_src

Y ahora es cuando tenemos el problema de que no podemos imprimir una colección de tipos. En algunos editores, pasando el ratón por encima de una directiva ~using~, es posible que veas el tipo resultante de aplicar estas funciones. Aunque también hay otro truquillo. Vamos a definir la estructura ~debug~ que nos permitirá ver el resultado de nuestras funciones cuando devuelvan tipos en lugar de valores.

#+begin_src C++ :exports both :eval never-export :results output :includes '(<iostream> "\"/home/hector/lispylambda/posts/C++/prueba.h\"")
  template<typename T>
  struct debug {};
 #+end_src

 Te estarás preguntando qué tiene de especial esta estructura para conseguir visualizar el resultado de nuestras funciones. La respuesta es nada. De hecho, puedes llamar a esta estructura como quieras. Lo que vamos a hacer es forzar un error intentando acceder a un miembro inexistente de la estructura ~debug~. Esto se ve mejor con un ejemplo.

#+begin_src C++ :exports both :eval never-export :results output :includes '(<iostream> "\"/home/hector/lispylambda/posts/C++/prueba.h\"")
  using foo = debug<concatenate_t<collection_t<int,float>,collection_t<char,double>>>::type;
 #+end_src

#+begin_src
  error: 'type' in 'struct debug<collection<int, float, char, double> >' does not name a type
 #+end_src
 
Vaya vaya. Así que no existe el atributo ~type~ en la estructura ~debug<collection<int,float,char,double>>~. Observa bien lo que hay escrito. Dentro de debug tenemos exactamente ~collection<int,float,char,double>~. Y está claro que esa es la concatenación de ~collection_t<int,float>~ y ~collection_t<char,double>~.

Sé que no es el método de debug más elegante, pero al menos funciona. Y si has pensado en usar la librería ~<typeinfo>~... no, no funciona. Aquí una prueba.

#+begin_src C++ :exports both :eval never-export :results output :includes '(<typeinfo> '(<iostream> "\"/home/hector/lispylambda/posts/C++/prueba.h\""))
  std::cout << typeid(concatenate_t<collection_t<int,float>,collection_t<char,double>>).name() << std::endl;
 #+end_src

 #+RESULTS:
 : 10collectionIJifcdEE

Yo la verdad es que no entiendo muy bien lo que pone ahí.

Vamos a detenernos de nuevo en la función concatenate.

#+begin_src C++ :exports both :eval never-export :results output :includes '(<iostream> "\"/home/hector/lispylambda/posts/C++/prueba.h\"")
  template<typename C, typename D>
  struct concatenate {};

  template<typename... CS, typename... DS>
  struct concatenate<collection<CS...>,collection<DS...>> : collection<CS...,DS...> {};

  template<typename C,typename D>
  using concatenate_t = typename concatenate<C,D>::type;
 #+end_src

 Observa la especialización de ~concatenate~. Fíjate en cómo estamos usando la especialización para darle un nombre a los elementos de cada colección. La primera colección tiene unos elementos que identificamos con ~CS~. Y para la segunda colección usamos el identificador ~DS~. Esta facilidad de darle un identificador a los elementos de una colección es lo que hace este tipo de contenedor sea tan útil para los templates de C++.

 Otro ejemplo interesante es la función para invertir el orden de los elementos de una colección.

#+begin_src C++ :exports both :eval never-export :results output :includes '(<iostream> "\"/home/hector/lispylambda/posts/C++/prueba.h\"")
  template<typename C, typename D>
  struct reverse_collection_aux {};

  template<typename... cs, typename... ds>
  struct reverse_collection_aux<collection<cs...>, collection<ds...>>
	  : collection_t<ds...> {};

  template<typename c, typename... cs, typename... ds>
  struct reverse_collection_aux<collection<c,cs...>, collection<ds...>>
	  : reverse_collection_aux<collection_t<cs...>, collection_t<c,ds...>> {};

  template<typename C>
  struct reverse_collection
	  : reverse_collection_aux<C, collection_t<>> {};

  template<typename C>
  using reverse_collection_t = typename reverse_collection<C>::type;
 #+end_src

 De nuevo, la especialización de los templates nos permite dar identificadores a los elementos de una colección, incluso a elementos concretos como en este caso, donde se le da el identificador ~c~ al primer elemento de la colección. Observa que la clave de esta función está en la segunda especialización, donde el elemento ~c~ pasa de la primera colección a la segunda. 

#+begin_src C++ :exports both :eval never-export :results output :includes '(<iostream> "\"/home/hector/lispylambda/posts/C++/prueba.h\"")
  using foo = debug<reverse_collection_t<collection_t<float,char,int>>>::type;
 #+end_src

#+begin_src
  error: 'type' in 'struct debug<collection<int, char, float> >' does not name a type
 #+end_src

Podríamos seguir definiendo funciones para las colecciones, pero sería mejor si llevásemos todo esto un poco más lejos. Sin embargo, necesitamos un tipo de dato que, aunque ya hemos visto, no lo hemos explotado lo suficiente. Me refiero a las funciones.

* Funciones de primera clase
En cualquier lenguaje funcional, las funciones son elementos de primera clase. Tienen su propio tipo y no los hace ni más ni menos especiales que cualquier otro tipo de dato. Sin embargo, en T++, los datos y las funciones se deben de tratar de diferente manera. Basta ver las diferencias entre un entero y la función ~add~. Al definir un entero en T++, estamos definiendo una estructura en C++. Sin embargo, la función ~add~ es una estructura templatizada, y a menos que le proporcionemos los argumentos necesarios, no será una estructura como tal. Todo esto se puede apreciar mejor cuando intentamos crear una función que acepte cada uno de los dos tipos de argumentos.

Esta sería la posible implementación de una función que puede recibir como argumento una función como ~add~.

#+begin_src C++ :exports both :eval never-export :results output :includes '(<iostream> "\"/home/hector/lispylambda/posts/C++/prueba.h\"")
  template<template<typename,typename> typename F>
  struct receiving_function : ... {};
 #+end_src

Y otra que recibiría un entero:

#+begin_src C++ :exports both :eval never-export :results output :includes '(<iostream> "\"/home/hector/lispylambda/posts/C++/prueba.h\"")
  template<typename I>
  struct receiving_integer : ... {};
 #+end_src

Es clara la diferencia. Mientras que en una debemos recibir un ~template<template<typename,typename> typename>~, en la otra recibimos ~template<typename>~.

Lo ideal sería tener un tipo de dato que nos permita manejar funciones al igual que los enteros. De esta forma podremos tener colecciones de funciones, por ejemplo.

Pues manos a la obra. Como no podemos predecir cuántos argumentos podrá recibir una función, podemos indicar que nuestro tipo de dato aceptará funciones con cualquier número de argumentos. Además, al igual que con ~integral_constant~ o las estructuras, definiremos el atributo ~type~ para que sea igual al propio tipo de la función.

También necesitaremos un atributo extra que nos permita ejecutar la función. Dicho atributo lo llamaré ~call~.

#+begin_src C++ :exports both :eval never-export :results output :includes '(<iostream> "\"/home/hector/lispylambda/posts/C++/prueba.h\"")
  template<template<typename...> typename F>
  struct function{
	using type = function;

	template<typename... A>
	using call = typename F<A...>::type;
  };
 #+end_src

Observa que ~call~ es un atributo templatizado. Simplemente recibe los argumentos que tiene que pasarle a la función ~F~.

Crear ahora un objeto de tipo ~function~ es muy sencillo. Por ejemplo, si queremos almacenar la función ~add~, basta usar ~function<add>~. De hecho, algo que deberíamos hacer a partir de ahora, es añadir una nueva definición cada vez que creemos una función nueva. Por ejemplo, para ~add~ deberíamos añadir lo siguiente:

#+begin_src C++ :exports both :eval never-export :results output :includes '(<iostream> "\"/home/hector/lispylambda/posts/C++/prueba.h\"")
  using add_f = function<add>;
 #+end_src

A partir de ahora, supondremos que todas las funciones definidas hasta ahora tienen definida su versión ~_f~. 

Ahora, podemos crear una función que ejecute un objeto de tipo ~function~.

#+begin_src C++ :exports both :eval never-export :results output :includes '(<iostream> "\"/home/hector/lispylambda/posts/C++/prueba.h\"")
  template<typename F, typename... A>
  struct funcall : F::template call<A...> {};

  template<typename F, typename... A>
  using funcall_t = typename funcall<F,A...>::type;

  template<typename F, typename... A>
  static constexpr typename funcall<F,A...>::value_type funcall_v = funcall<F,A...>::value;

  using funcall_f = function<funcall>;
 #+end_src

En lugar de acceder al atributo templatizado ~call~ cada vez que queramos ejecutar una función, usaremos la función ~funcall~. Esta función recibe un objeto de tipo ~function~ y sus argumentos. Devolverá el resultado de ejecutar la función con esos argumentos.

#+begin_src C++ :exports both :eval never-export :results output :includes '(<iostream> "\"/home/hector/lispylambda/posts/C++/prueba.h\"")
  std::cout << funcall_v<add_f,int_constant<5>,int_constant<6>> << std::endl;
 #+end_src

 #+RESULTS:
 : 11
 
Otra función parecida a ~funcall~ es ~apply~. La diferencia está en que el último argumento debe ser una colección de argumentos. De esta forma, la función pasada a ~apply~ es ejecutada con los primeros argumentos pasados más los encontrados en la colección del último argumento.

#+begin_src C++ :exports both :eval never-export :results output :includes '(<iostream> "\"/home/hector/lispylambda/posts/C++/prueba.h\"")
  template<typename F, typename C, typename... A>
  struct apply_aux {};

  template<typename F, typename... CS, typename A, typename B, typename... AS>
  struct apply_aux<F,collection<CS...>,A,B,AS...> : apply_aux<F,collection<CS...,A>,B,AS...> {};

  template<typename F, typename... CS, typename... AS>
  struct apply_aux<F,collection<CS...>,collection<AS...>> : funcall<F,CS...,AS...> {};

  template<typename F, typename... A>
  struct apply : apply_aux<F,collection<>,A...> {};

  template<typename F, typename... A>
  using apply_t = typename apply<F,A...>::type;

  template<typename F, typename... A>
  static constexpr typename apply<F,A...>::value_type apply_v = apply<F,A...>::value;

  using apply_f = function<apply>;
 #+end_src

Como no podemos obtener directamente el último argumento de una colección, debemos ir guardando cada uno de los argumentos anteriores hasta que sepamos que sólo nos queda uno (el último). En ese momento, ejecutamos la función usando ~funcall~.

Para probarla, podemos definir una nueva función que sume todos los enteros de una colección. Normalmente necesitaríamos recorrer la colección usando recursividad, pero con ~apply~, es innecesario:

#+begin_src C++ :exports both :eval never-export :results output :includes '(<iostream> "\"/home/hector/lispylambda/posts/C++/prueba.h\"")
  template<typename C>
  struct sum : apply<add_f,C> {};

  template<typename C>
  using sum_t = typename sum<C>::type;

  template<typename C>
  static constexpr int sum_v = sum<C>::value;

  using sum_f = function<sum>;
 #+end_src

Demasiado fácil para ser verdad. Pero funciona.

#+begin_src C++ :exports both :eval never-export :results output :includes '(<iostream> "\"/home/hector/lispylambda/posts/C++/prueba.h\"")
  using myList = collection_t<int_constant<1>,int_constant<2>,int_constant<3>>;

  std::cout << sum_v<myList> << std::endl;
 #+end_src

 #+RESULTS:
 : 6

* Mucho texto...

Asumámoslo, definir una función en T++ requiere mucho texto. En particular, es bastante tedioso tener que escribir cada vez esas versiones cortas acabadas en ~_t~, ~_v~ o ~_f~. ¿Podemos ponerle algún remedio? Pues claro. Si no pudiésemos o no se me hubiese ocurrido nada, no existiría esta sección que estás leyendo. 

A pesar de no tener un buen sistema de macros como sí tienen los lenguajes de la familia Lisp (Common Lisp, Scheme, Clojure o Scheme, entro otros), de algo nos pueden servir en este caso. Además, el simple hecho de tener el nombre de 'Macro' es una gran injusticia. El sistema de """"""Macros"""""" de C++ no le llega ni  a la suela de los zapatos a uno de verdad. Ahora que ya me he desahogado, podemos proseguir ~:D~.

Si nos fijamos en estas versiones cortas que hemos ido escribiendo, podemos ver algunos patrones que van a ser claves para crear una """"""Macro"""""" (vale, ya paro) que nos facilite un poco la vida. Veamos dos ejemplos:

#+begin_src C++ :exports both :eval never-export :results output :includes '(<iostream> "\"/home/hector/lispylambda/posts/C++/prueba.h\"")
   template<typename N, typename M>
   struct mult : int_constant<N::value * M::value> {};

   template<typename N, typename M>
   using mult_t = typename mult<N,M>::type;  

   template<typename N, typename M>
   constexpr int mult_v = mult<N,M>::value;

   using mult_f = function<mult>;
 #+end_src

#+begin_src C++ :exports both :eval never-export :results output :includes '(<iostream> "\"/home/hector/lispylambda/posts/C++/prueba.h\"")
   // ....

  template<typename F, typename... A>
  struct apply : apply_aux<F,collection<>,A...> {};

  template<typename F, typename... A>
  using apply_t = typename apply<F,A...>::type;

  template<typename F, typename... A>
  static constexpr typename apply<F,A...>::value_type apply_v = apply<F,A...>::value;

  using apply_f = function<apply>;
 #+end_src

Observa, que a pesar de tener diferencias, la definición de las abreviaciones es bastante parecida en ambos casos. Si nos fijamos únicamente en dichas diferencias sabremos qué debe recibir nuestra macro. Es decir, nuestra macro recibirá esas partes que cambian de función a función.

Podemos apreciar ~4~ diferencias en total: El nombre de la función, la declaración de los argumentos de cada template, cómo se pasan dichos argumentos a la función, y el tipo del valor devuelto por la abreviación ~_v~. Por tanto, la macro podría ser de la siguiente manera:

#+begin_src C++ :exports both :eval never-export :results output :includes '(<iostream> "\"~/lispylambda/posts/C++/prueba.h\"")
#define canonize(name, tempArg, call, valType)      \
  tempArgs                                              \
  using name##_t = typename call##::type;               \
                                                        \
  tempArgs                                              \
  static constexpr valType name##_v = call##::value;    \
                                                        \
  using name##_f = function<name>
 #+end_src

Y podríamos usarla de la siguiente manera...

#+begin_src C++ :exports both :eval never-export :results output :includes '(<iostream> </home/hectarea/lispylambda/posts/C++/prueba.h>)
canonize(apply, template<typename F, typename... A>, apply<F,A...>, typename apply<F,A...>::value_type);
 #+end_src

 #+begin_src
 error: macro "canonize" passed 7 arguments, but takes just 4
 #+end_src
 
...si no fuese por las comas entre los argumentos de los templates. ¡Pero no nos rendimos! Además, ¡esta sección existe! ¡debe ser posible! ... ¿verdad?

A ver, busquemos en [[https://en.cppreference.com/w/cpp/preprocessor/replace][cppreference]]: ~Note: if an argument of a function-like macro includes commas that are not protected by matched pairs of left and right parentheses (most commonly found in template argument lists, as in assert(std::is_same_v<int, int>); or BOOST_FOREACH(std::pair<int, int> p, m)), the comma is interpreted as macro argument separator, causing a compilation failure due to argument count mismatch.~

¡Bien! Es lo que nos está ocurriendo y además nos dice cómo podemos solucionarlo. De alguna manera tenemos que introducir las comas entre paréntesis. Pero de alguna manera tenemos que eliminarlos después de que se expanda la macro. ¡Ya sé! Podemos poner dicho argumento entre paréntesis justo al lado de una macro. De esta forma, se ejecutará dicha macro que devolverá el argumento que está recibiendo. Sé que me explico fatal. Por lo que veamos paso a paso cómo hacerlo.

1. Primero definimos la macro ~EXPAND~. Recibe un argumento y lo devuelve, sin más:

#+begin_src C++ :exports both :eval never-export :results output :includes '(<iostream> </home/hectarea/lispylambda/posts/C++/prueba.h>)
#define EXPAND(X) X
 #+end_src

Ahora, sólo tenemos que cambiar ~canonize~ introduciendo una llamada a ~EXPAND~ cada vez que usemos un argumento:

#+begin_src C++ :exports both :eval never-export :results output :includes '(<iostream> "\"~/lispylambda/posts/C++/prueba.h\"")
#define EXPAND(X) X
#define canonize(name, tempArgs, call, valType)                      \
  EXPAND tempArgs                                                       \
  using name##_t = typename EXPAND call ::type;                         \
                                                                        \
  EXPAND tempArgs                                                       \
  static constexpr EXPAND valType name##_v = EXPAND call ::value;       \
                                                                        \
  using name##_f = function<name>;
 #+end_src

El único argumento que no necesita ~EXPAND~ es ~name~, pues nunca podrá tener una coma al tener que referirse siempre al nombre de una función.

Probemos la macro definiendo una función sencilla. Esta función que llamaremos ~first~ debe devolver el primer elemento de una colección. Si la función recibe una colección vacía se generará un error.

#+begin_src C++ :exports both :eval never-export :results output :includes '(<iostream> "\"~/lispylambda/posts/C++/prueba.h\"")
template<typename C>
struct first {};

template<typename C, typename... CS>
struct first<collection<C,CS...>> : C {};
 #+end_src

Y definimos las funciones cortas con la nueva macro:

#+begin_src C++ :exports both :eval never-export :results output :includes '(<iostream> </home/hectarea/lispylambda/posts/C++/prueba.h>)
canonize(first, (template<typename C>), (first<C>), (typename first_t<C>::value_type));
 #+end_src

Veamos si funciona:

#+begin_src C++ :exports both :eval never-export :results output :includes '(<iostream> </home/hectarea/lispylambda/posts/C++/prueba.h>)
std::cout << first_v<collection<int_constant<10>, int_constant<2>>> << std::endl;
 #+end_src

 #+RESULTS:
 : 10

¡Perfecto! Ya te dije que esta sección estaba aquí por algo.

Pero podemos hacerlo mejor. Observa el segundo argumento que le pasamos a ~canonize~. Siempre le vamos a pasar la palabra ~template~ al inicio, además de los símbolos ~<~ y ~>~. Por otro lado, en el tercer argumento ocurre algo parecido, siempre vamos a utilizar el nombre de la función para realizar la llamada, pero dicho nombre ya lo estamos recibiendo como primer argumento. Cambiemos un poco la definición:

#+begin_src C++ :exports both :eval never-export :results output :includes '(<iostream> "\"~/lispylambda/posts/C++/prueba.h\"")
#define EXPAND(X) X
#define canonize(name, tempArgs, call, valType)                      \
  template<EXPAND tempArgs>                                                       \
  using name##_t = typename name<EXPAND call> ::type;                         \
                                                                        \
  EXPAND tempArgs                                                       \
  static constexpr EXPAND valType name##_v = name<EXPAND call> ::value;       \
                                                                        \
  using name##_f = function<name>;
 #+end_src

Su uso quedaria ahora de la siguiente manera:

#+begin_src C++ :exports both :eval never-export :results output :includes '(<iostream> "\"~/lispylambda/posts/C++/prueba.h\"")
canonize(first, (typename C), (C), (typename first_t<C>::value_type));
 #+end_src

Usando otro ejemplo, para la función ~add~ quedaria así:

#+begin_src C++ :exports both :eval never-export :results output :includes '(<iostream> "\"~/lispylambda/posts/C++/prueba.h\"")
canonize(add, (typename A, typename B), (A,B), (int));
 #+end_src

Bastante mejor que antes. Cuanto menos haya que escribir, mejor. Pero podemos hacerlo aún mejor. En C++ podemos usar la directiva ~auto~ para dejarle que deduzca el tipo de dato de una variable. Si la usamos, ya no tendremos que pasarle a nuestra macro el último argumento.

#+begin_src C++ :exports both :eval never-export :results output :includes '(<iostream> "\"~/lispylambda/posts/C++/prueba.h\"")
#define EXPAND(X) X
#define canonize(name, tempArgs, call)                      \
  template<EXPAND tempArgs>                                                       \
  using name##_t = typename name<EXPAND call> ::type;                         \
                                                                        \
  EXPAND tempArgs                                                       \
  static constexpr auto name##_v = name<EXPAND call> ::value;       \
                                                                        \
  using name##_f = function<name>;
 #+end_src

Ahora su uso es más corto aún:

#+begin_src C++ :exports both :eval never-export :results output :includes '(<iostream> "\"~/lispylambda/posts/C++/prueba.h\"")
canonize(first, (typename C), (C));
canonize(add, (typename A, typename B), (A,B));
 #+end_src

¡Pero podemos hacerlo aún mejor! Los argumentos de nuestros templates siempre van a ser tipos. Podemos hacer que todos los templates reciban siempre una cantidad variable de argumentos. Esto es válido, pues hasta que no se use un template, éste no se instancia y C++ no sabrá hasta entonces si la cantidad de argumentos que se ha pasado es correcta o no. Cambiemos de nuevo la definición.

#+begin_src C++ :exports both :eval never-export :results output :includes '(<iostream> "\"~/lispylambda/posts/C++/prueba.h\"")
#define EXPAND(X) X
#define canonize(name)                                  \
  template<typename... TS>                              \
  using name##_t = typename name<TS...> ::type;         \
                                                        \
  template<typename... TS>                              \
  static constexpr auto name##_v = name<TS...> ::value; \
                                                        \
  using name##_f = function<name>;
 #+end_src

Espera un momento... Nos hemos quedado con... ¡¿sólo un argumento?! ¡Genial!

#+begin_src C++ :exports both :eval never-export :results output :includes '(<iostream> "\"~/lispylambda/posts/C++/prueba.h\"")
canonize(first);
canonize(add);
 #+end_src

Crear ahora estas abreviaciones es ¡demasiado fácil! ¡Pero funciona!

Lo mejor de todo, es que si en un futuro no muy lejano se nos ocurre añadir alguna nueva abreviación, sólo tendremos que añadirla a nuestra macro, y automáticamente ¡todas nuestras funciones tendrán esa nueva abreviación!  

* Más colecciones

Las colecciones son bastante útiles y por eso vale la pena seguir definiendo funciones que nos permitan manipularlas con facilidad. Por ahora tenemos ~is_empty~, ~concatenate~, ~reverse_collection~ y ~first~. Vamos a intentar definir aquellas que son básicas, aquellas que nos permitan añadir elementos, contarlos, etc.

Empezamos con ~cons~. Esta función añade un elemento al inicio de una colección.

#+begin_src C++ :exports both :eval never-export :results output :includes '(<iostream> "\"~/lispylambda/posts/C++/prueba.h\"")
template<typename V, typename C>
struct cons {};

template<typename V, typename... CS>
struct cons<V, collection<CS...>> : collection<V,CS...> {};

canonize(cons);
 #+end_src

El argumento ~V~ es el elemento que queremos insertar, y el segundo argumento es la colección donde queremos insertar el elemento.

#+begin_src C++ :exports both :eval never-export :results output :includes '(<iostream> </home/hectarea/lispylambda/posts/C++/prueba.h>)
std::cout << first_v<cons_t<int_constant<5>,collection<int_constant<7>>>> << std::endl;
 #+end_src

 #+RESULTS:
 : 5

Si podemos añadir elementos, también deberíamos poder eliminarlos. Creamos la función ~rest~.

#+begin_src C++ :exports both :eval never-export :results output :includes '(<iostream> "\"~/lispylambda/posts/C++/prueba.h\"")
template<typename C>
struct rest {};

template<typename C, typename... CS>
struct rest<collection<C,CS...>> : collection<CS...> {};

template<typename... CS>
struct rest<collection<CS...>> : collection<CS...> {};

canonize(rest);
 #+end_src

#+begin_src C++ :exports both :eval never-export :results output :includes '(<iostream> </home/hectarea/lispylambda/posts/C++/prueba.h>)
std::cout << first_v<rest_t<collection<int_constant<5>, int_constant<7>>>> << std::endl;
 #+end_src

 #+RESULTS:
 : 7

Otra función que es bastante común es ~range~. Recibe un entero y devuelve una colección con todos los números no negativos menores que él.

#+begin_src C++ :exports both :eval never-export :results output :includes '(<iostream> </home/hectarea/lispylambda/posts/C++/prueba.h>)
template<typename N, typename I>
struct range_aux {};

template<int k>
struct range_aux<int_constant<k>,int_constant<k>> : collection<> {};

template<int n, int i>
struct range_aux<int_constant<n>, int_constant<i>>
  : cons<int_constant<n>, typename range_aux<int_constant<n+1>, int_constant<i>>::type> {};

template<typename I>
struct range : range_aux<int_constant<0>, I> {};

canonize(range);
 #+end_src

Ahora podemos, por ejemplo, calcular la suma de los 100 primeros números naturales:

#+begin_src C++ :exports both :eval never-export :results output :includes '(<iostream> </home/hectarea/lispylambda/posts/C++/prueba.h>)
std::cout << sum_v<range_t<int_constant<101>>> << std::endl;
 #+end_src

 #+RESULTS:
 : 5050

Otra función más: ~length~. Creo que no es necesario ni explicar qué va a hacer.

#+begin_src C++ :exports both :eval never-export :results output :includes '(<iostream> </home/hectarea/lispylambda/posts/C++/prueba.h>)
template<typename C>
struct length {};

template<>
struct length<collection<>> : int_constant<0> {};

template<typename C, typename... CS>
struct length<collection<C,CS...>> : add1<typename length<collection<CS...>>::type> {};

canonize(length);
 #+end_src

Podemos comprobar su validez con ~range~:

#+begin_src C++ :exports both :eval never-export :results output :includes '(<iostream> </home/hectarea/lispylambda/posts/C++/prueba.h>)
std::cout << length_v<range_t<int_constant<5>>> << std::endl;
 #+end_src

 #+RESULTS:
 : 5

Perfecto.

A partir de aquí se vienen un poco de curvas. Vamos a definir las funciones ~zip~, ~unzip~ y ~map~. El problema está en que ~map~ es fácil de implementar si tenemos ~zip~, pero ~zip~ es fácil de implementar si tienemos ~map~. Así que de alguna manera tenemos que ensuciarnos las manos con recursividad en alguna de las funciones. 

Empezaremos con una versión simplificada de ~map~: ~map_single~. Esta función crea una colección con los resultados de aplicar una función recibida a cada uno de los elementos de una colección recibida.

#+begin_src C++ :exports both :eval never-export :results output :includes '(<iostream> </home/hectarea/lispylambda/posts/C++/prueba.h>)
template<typename F, typename C>
struct map_single {};

template<typename F, typename... CS>
struct map_single<F, collection<>> : collection<> {};

template<typename F, typename C, typename... CS>
struct map_single<F, collection<C,CS..>>
  : cons<funcall_t<F,C>, typename map_single<F, collection<CS...>>::type> {};

canonize(map_single);
 #+end_src

Vamos a hacer una pequeña prueba:

#+begin_src C++ :exports both :eval never-export :results output :includes '(<iostream> </home/hectarea/lispylambda/posts/C++/prueba.h>)
std::cout << sum_v<map_single_t<add1_f, range_t<int_constant<3>>>> << std::endl;
 #+end_src

 #+RESULTS:
 : 6

Perfecto. La llamada a ~range_t<int_constant<3>>~ ha creado el tipo ~collection<int_constant<0>,int_constant<1>,int_constant<2>>~. Al sumarle ~1~ a cada uno de estos elementos con ~add1_f~ conseguimos una colección con los números ~1~, ~2~ y ~3~. Y la suma de estos 3 números es, efectivamente, ~6~.

Vamos a necesitar también la función ~and_bool~. En los primeros capítulos definimos ~or_bool~ que aplicaba la operación lógica ~or~ sobre dos ~bool_constant~. Vamos a generalizar estas funciones para que acepten una cantidad variable de argumentos.

#+begin_src C++ :exports both :eval never-export :results output :includes '(<iostream> </home/hectarea/lispylambda/posts/C++/prueba.h>)
template<typename... BS>
struct and_bool {};

template<>
struct and_bool<> : bool_constant<true> {};

template<typename B>
struct and_bool<B> : B {};

template<bool a, bool b, typename... BS>
struct and_bool<bool_constant<a>, bool_constant<b>, BS...>
  : and_bool<bool_constant<a && b>, BS...> {};

canonize(and_bool);
 #+end_src

Con esto ya tenemos herramientas para crear ~zip~ de manera relativamente cómoda. Esta función recibe una cantidad variable de colecciones y creará una colección de colecciones. La primera colección contiene los primeros elementos de las colecciones recibidas. La segunda, los segundos elementos. Y así, hasta que alguna colección recibida no tenga más elementos. La complicación de esta función reside principalmente en ir comprobando que alguna de las colecciones se quede vacía para terminar la evaluación. Para ello, usamos una función ~zip_aux~ que recibe además un booleano indicando si debemos terminar o no, es decir, si alguna colección ya no tiene elementos.

#+begin_src C++ :exports both :eval never-export :results output :includes '(<iostream> </home/hectarea/lispylambda/posts/C++/prueba.h>)
template<bool stop, typename... CS>
struct zip_aux {};
 #+end_src

Si debemos parar devolvemos una colección vacía.

#+begin_src C++ :exports both :eval never-export :results output :includes '(<iostream> </home/hectarea/lispylambda/posts/C++/prueba.h>)
template<typename... CS>
struct zip_aux<false, CS...> : collection<> {};
 #+end_src

Si debemos seguir, necesitamos calcular varias cosas. 

Primero, debemos determinar si en la siguiente llamada deberemos continuar o no. Para ello, para cada una de las colecciones debemos eliminar el primer elemento y comprobar que la colección resultante está vacía. Si alguna de esas colecciones es vacía entonces debemos indicar con el valor ~true~ que debemos parar. Parecen muchas cosas, pero tenemos bastantes herramientas. Para poder eliminar el primer elemento de una colección usamos ~rest~. Y si queremos hacerlo para cada colección basta usar ~map_single~. Es decir, si ~CS...~ son nuestras colecciones, entonces basta evaluar ~map_single_t<rest_f,collection<CS...>>~. Ahora queremos saber si alguna de las colecciones que está dentro de la colección devuelta por la anterior llamada está vacía. Para saber si una colección está vacía usamos ~is_empty~. Si queremos usar la función para cada colección usamos de nuevo ~map_single_t~. La llamada a realizar, por ahora, sería ~map_single_t<is_empty_f,map_single_t<rest_f,collection<CS...>>>~. Esto nos devuelve una colección de ~bool_constant~. Si alguno de estos booleanos es ~false~, entonces devolvemos ~false~. Eso es aplicar la operación lógica ~and~. Y aquí entra ~and_bool~. Pero ~and_bool~ acepta una cantidad variable de booleanos, no una colección. No pasa nada, porque podemos usar ~apply~. Con todo esto la llamada final sería ~apply_v<and_bool_f,map_single_t<is_empty_f,map_single_t<rest_f,collection<CS...>>>>~. 

En segundo lugar, debemos coger los primeros elementos de cada colección e introducirlos en una nueva. Como ~CS...~ son las colecciones que hemos recibido habría que evaluar los siguiente: ~collection<first_t<CS>...>~. Sencillo.

Por último, la parte de recursividad. Debemos llamar a la propia función ~zip~ con las colecciones recibidas habiendo eliminado el primer elemento. La llamada sería ~zip_aux<'el booleano de antes', rest_t<CS>...>~. 

Ahora, para juntarlo todo, debemos coger la colección obtenida del segundo punto y añadirlo como primer elemento a la colección de colecciones obtenida por el tercer punto. 

#+begin_src C++ :exports both :eval never-export :results output :includes '(<iostream> </home/hectarea/lispylambda/posts/C++/prueba.h>)
template<typename... CS>
struct zip_aux<true, CS...> 
  : cons<collection<first_t<CS>...>, 
         typename zip_aux<apply_v<and_bool_f,map_single_t<is_empty_f,map_single_t<rest_f,collection<CS...>>>>,
                          rest_t<CS>...>::type> {};
 #+end_src

Ya solo queda crear ~zip~ usando ~zip_aux~. Todo el código quedaría así:

#+begin_src C++ :exports both :eval never-export :results output :includes '(<iostream> </home/hectarea/lispylambda/posts/C++/prueba.h>)
template<bool stop, typename... CS>
struct zip_aux {};

template<typename... CS>
struct zip_aux<false, CS...> : collection<> {};

template<typename... CS>
struct zip_aux<true, CS...> 
  : cons<collection<first_t<CS>...>, 
         typename zip_aux<apply_v<and_bool_f,map_single_t<is_empty_f,map_single_t<rest_f,collection<CS...>>>>,
                          rest_t<CS>...>::type> {};

template<typename... CS>
struct zip : zip_aux<apply_v<and_bool_f,map_single_t<is_empty_f,CS...>>,
                     CS...>
 #+end_src

Observa que para llamar a ~zip_aux~ en ~zip~ tenemos que comprobar también si alguna de las colecciones está vacía. Al menos no tenemos que eliminar el elemento inicial, por lo que la llamada es más sencilla.
