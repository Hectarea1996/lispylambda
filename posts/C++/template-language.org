#+TITLE: T++: El lenguaje oculto tras los Templates
#+date:<2023-07-30 do.>

Te propongo lo siguiente: Vamos a aprender un lenguaje de programación nuevo. Lo llamaremos *T++*. Es un lenguaje funcional puro, pero no te preocupes, iremos poco a poco si nunca te has enfrentado con algo así.

T++ es un lenguaje que se usa sobre C++. Por ello, podemos crear una función ~main~ común y corriente para poder comprobar el código que vayamos haciendo. Además, incluiremos una librería indispensable para poder usar T++: *type_traits*.

#+begin_src C++
  #include <iostream>
  #include <type_traits>

  // Aqui declararemos todas las funciones

  int main(){

	  // Aquí porbaremos las funciones

	  return 0;
  }
#+end_src

* Tipos de datos primitivos
En T++ los tipos de datos primitivos son estructuras creadas a partir de la expresión ~std::integral_constant~. Esta expresión recibe un tipo de C++ y un valor de dicho tipo. Entre los tipos permitidos se encuentran los tipos integrales, los punteros o incluso las referencias.

#+begin_quote
A partir de C++20 tenemos incluso tipos de coma flotante.
#+end_quote

 Pero empecemos por lo sencillo. Los tipos integrales incluyen los enteros, booleanos o caracteres, entre otros. En T++, para definir un tipo integral ya hemos dicho que debemos usar ~std::integral_constant<type,value>~. Por ejemplo, si queremos crear el entero ~5~ en T++, usamos la expresión ~std::integral_constant<int,5>~. Es más, con ~using~ podemos definir aliases para estos valores de T++.

 #+begin_src C++ :exports both :eval never-export :results output :includes "C:/Users/hecto/Documents/GitHub/lispylambda/posts/C++/prueba.h"
   using cinco = std::integral_constant<int,5>;
 #+end_src 

Pero ojo, esto es un tipo en C++ que representa al valor ~5~. Si queremos *extraer* el valor que se encuentra en su interior, debemos añadir ~::value~.

 #+begin_src C++ :exports both :eval never-export :results output :includes "C:/Users/hecto/Documents/GitHub/lispylambda/posts/C++/prueba.h"
   std::cout << cinco::value << std::endl;
 #+end_src

 #+RESULTS:
 : 5

Podemos hacer lo mismo con un booleano:

 #+begin_src C++ :exports both :eval never-export :results output :includes "C:/Users/hecto/Documents/GitHub/lispylambda/posts/C++/prueba.h"
   using myFalse = std::integral_constant<bool,false>;

   std::cout << myFalse::value << std::endl;
 #+end_src

 #+RESULTS:
 : 0

Pero observemos cómo hemos construido estos valores. Hemos usado ~std::integral_constant~. Pero, ¿qué es esta expresión en T++? Pues como veremos a continuación, es una función de T++. Aunque también se conocen como meta-funciones en C++.
 
* Funciones
Yendo al grano, una función en T++ va a ser una estructura (templatizada o no) que contenga al menos un atributo ~type~ y, opcionalmente, un atributo ~value~.

Nosotros ya hemos usado una función, ~std::integral_constant~. De hecho, podríamos haber creado esta función de la siguiente manera:

 #+begin_src C++ :exports both :eval never-export :results output :includes "C:/Users/hecto/Documents/GitHub/lispylambda/posts/C++/prueba.h"
   template<typename T, T v>
   struct integral_constant{
	   using type = integral_constant;
	   static constexpr T value = v;
   };
 #+end_src

Para empezar nuestra aventura con las funciones, vamos a crear una que nos permita crear un entero de T++ a partir de un entero de C++. Sin embargo, vamos a hacerlo un poco diferente a la posible ~integral_constant~ que acabamos de hacer. Recuerda que los atributos como ~type~ o ~value~ se pueden heredar. Por tanto sólo tenemos que heredar del tipo correcto para terminar hacer nuestra función.

 #+begin_src C++ :exports both :eval never-export :results output :includes "C:/Users/hecto/Documents/GitHub/lispylambda/posts/C++/prueba.h"
   template<int k>
   struct int_constant : std::integral_constant<int,k>{};
 #+end_src

 Y listo! Si no te fías, recuerda la definición de función en T++. Hemos hecho una estructura templatizada que recibe un entero. Como heredamos de la estructura ~std::integral_constant<int,k>~, conseguimos gratuitamente todos sus atributos, incluidos el atributo ~type~ y su atributo ~value~.

 #+begin_src C++ :exports both :eval never-export :results output :includes "C:/Users/hecto/Documents/GitHub/lispylambda/posts/C++/prueba.h"
   std::cout << int_constant<42>::value << std::endl;
 #+end_src

 #+RESULTS:
 : 42

Al usar la expresión ~int_constant<42>~ estamos llamando a la función ~int_constant~ con el parámetro ~42~. Además accedemos a su valor usando el atributo ~value~.

Usar el atributo ~value~ es tan común que para cada función de T++ suele crearse otro template que accede directamente a dicho atributo. Hagámos lo mismo.

 #+begin_src C++ :exports both :eval never-export :results output :includes "C:/Users/hecto/Documents/GitHub/lispylambda/posts/C++/prueba.h"
   template<int k>
   constexpr int int_constant_v = int_constant<k>::value;
 #+end_src

 De esta forma es más cómo acceder a los valores que contienen nuestro valores de T++.
 
 #+begin_src C++ :exports both :eval never-export :results output :includes "C:/Users/hecto/Documents/GitHub/lispylambda/posts/C++/prueba.h"
   std::cout << int_constant_v<-6> << std::endl;
 #+end_src

 #+RESULTS:
 : -6

 Hasta ahora hemos usado ~value~, pero este era el atributo opcional. El atributo obligatorio es ~type~ y, sin embargo, no lo hemos usado aún. Pues te pido un poco de paciencia, pues será en nuestra siguiente función donde veamos la utilidad de ~type~. Por ahora, debemos quedarnos con que tenemos que crear otro template para cada función de T++ que acceda directamente al atributo ~type~. Hagámoslo con ~int_constant~.

 #+begin_src C++ :exports both :eval never-export :results output :includes "C:/Users/hecto/Documents/GitHub/lispylambda/posts/C++/prueba.h"
   template<int k>
   using int_constant_t = typename int_constant<k>::type;
 #+end_src

 Observa que este template no es una nueva estructura. Estamos usando ~using~ para crear un alias de ~int_constant<k>::type~.

 Ahora sí, pasemos a la siguiente función. La función de suma de dos enteros. Debemos recibir dos enteros de T++ y devolver su suma.
 
#+begin_src C++ :exports both :eval never-export :results output :includes "C:/Users/hecto/Documents/GitHub/lispylambda/posts/C++/prueba.h"
  template<typename A, typename B>
  struct add : int_constant<A::value+B::value>{};
 #+end_src

 Recuerda que los valores en T++ siguen siendo tipos en C++, es por eso que el template recibe dos ~typename~. Cada uno debería ser un entero de T++. Y para indicar que devolvemos otro entero hacemos que ~add~ herede de ~int_constant~. De esta forma tendremos sus atributos ~value~ y ~type~. En este caso ~value~ tendrá el valor que recibe ~int_constant~, que es la suma de ~A~ y ~B~.

Siguiendo la tradición, debemos crear los templates ~_v~ y ~_t~:

#+begin_src C++ :exports both :eval never-export :results output :includes "C:/Users/hecto/Documents/GitHub/lispylambda/posts/C++/prueba.h"
  template<typename A, typename B>
  constexpr int add_v = add<A,B>::value;

  template<typename A, typename B>
  using add_t = add<A,B>::type;
 #+end_src

 Y podemos probar nuestra nueva función para comprobar si es correcta:

 #+begin_src C++ :exports both :eval never-export :results output :includes "C:/Users/hecto/Documents/GitHub/lispylambda/posts/C++/prueba.h"
   using tres = int_constant<3>;
   using cinco = int_constant<5>;

   std::cout << add_v<tres,cinco> << std::endl;
 #+end_src

 #+RESULTS:
 : 8

 Ahora bien, en el código anterior hay un detalle que hace que no sea del todo correcto. ¿Recuerdas cómo definimos el valor ~5~ en la sección anterior? Lo definimos usando ~std::integral_constant~. Pero ahora hemos usado ~int_constant~. A primera vista parecen lo mismo, porque hemos dicho que ~int_constant~ es una función que devolvía un valor en T++. Pero la realidad es que son tipos diferentes. Y esto puede ocasionar problemas más adelante. Aquí es cuando entra en juego el atributo ~type~. Este atributo es lo que nos permite realmente devolver el valor de una función en T++. En nuestro caso, recuerda que ~int_constant~ se definía heredando de ~std::integral_constant~, por lo que hereda su atributo ~type~, que se inicializaba al propio ~std::integral_constant~. Por tanto, en el ejemplo anterior, lo correcto es usar el atributo ~type~ para crear ~tres~ y ~cinco~. O, equivalentemente, el template que acaba en ~_t~.

 #+begin_src C++ :exports both :eval never-export :results output :includes "C:/Users/hecto/Documents/GitHub/lispylambda/posts/C++/prueba.h"
   using tres = int_constant_t<3>;
   using cinco = int_constant_t<5>;

   std::cout << add_v<tres,cinco> << std::endl;
 #+end_src

 #+RESULTS:
 : 8

 En este ejemplo ya hemos visto que el cambio no afecta al resultado, pero en ciertas funciones puede suponer el cambio entre la perfección y el desastre.

* Más funciones
Seguimos viendo ejemplos de algunas funciones un poco más avanzadas. Por ejemplo, estaría bien una función que nos diga si un entero es cero o no. Es decir, debe recibir un entero de T++ (~std::integral_constant~) y devolver un booleano de T++ (otro ~std::integral_constant~).

Para esta función es necesario usar las especializaciones de templates. Date cuenta que no existe ningún tipo de ~if~ en templates. O mejor dicho, las especializaciones son nuestro ~if~. La idea general es poner lo que es falso en el template general, y lo verdadero en las especializaciones.

 #+begin_src C++ :exports both :eval never-export :results output :includes "C:/Users/hecto/Documents/GitHub/lispylambda/posts/C++/prueba.h"
   template<typename T>
   struct isZero
	   : bool_constant<false> {};

   template<>
   struct isZero<std::integral_constant<int,0>>
	   : bool_constant<true> {};
 #+end_src

Observa que hemos usado el tipo ~bool_constant~. Es como ~int_constant~, pero para booleanos. Se define de la misma forma.
 
 Creamos también los correspondientes templates ~_v~ y ~_t~.

#+begin_src C++ :exports both :eval never-export :results output :includes "C:/Users/hecto/Documents/GitHub/lispylambda/posts/C++/prueba.h"
  template<typename T>
  constexpr bool isZero_v = isZero<T>::value;

  template<typename T>
  using isZero_t = typename isZero<T>::type;
 #+end_src

 Vamos a probar la función.

#+begin_src C++ :exports both :eval never-export :results output :includes "C:/Users/hecto/Documents/GitHub/lispylambda/posts/C++/prueba.h"
  std::cout << isZero_v<int_constant<0>> << std::endl;
 #+end_src

 #+RESULTS:
 : 0
 
 Le pasamos a la función el valor ~0~ y la función nos devuelve verdadero. Espera... ha devuelto falso. ¡Claro! Recuerda lo que dijimos sobre ~type~. Le estamos pasando a ~isZero~ el tipo ~int_constant~ cuando realmente le tenemos que pasar ~std::integral_constant~. Basta aquí cambiar ~int_constant~ por ~int_constant_t~.

 #+begin_src C++ :exports both :eval never-export :results output :includes "C:/Users/hecto/Documents/GitHub/lispylambda/posts/C++/prueba.h"
  std::cout << isZero_v<int_constant_t<0>> << std::endl;
 #+end_src

 #+RESULTS:
 : 1

Observa de nuevo la definición de ~isZero~. La especialización se realiza sobre el tipo ~integral_constant~. Es por ello que con ~int_constant~ se devolvía el valor falso. Lo mismo ocurriría si utilizásemos ~add~ en lugar de ~add_t~.

 #+begin_src C++ :exports both :eval never-export :results output :includes "C:/Users/hecto/Documents/GitHub/lispylambda/posts/C++/prueba.h"
   using cuatro = int_constant_t<4>;
   using menosCuatro = int_constant_t<-4>;

   std::cout << isZero_v<add<cuatro,menosCuatro>> << std::endl;

   std::cout << isZero_v<add_t<cuatro,menosCuatro>> << std::endl;
 #+end_src

 #+RESULTS:
 : 0
 : 1

A partir de aquí podemos hacer todas las funciones que manejen valores primitivos de T++ que se nos ocurran. Aquí tienes unas cuantas:

 #+begin_src C++ :exports both :eval never-export :results output :includes "C:/Users/hecto/Documents/GitHub/lispylambda/posts/C++/prueba.h"
   /// or operator
   template<typename B, typename C>
   struct or_bool : bool_constant<B::value || C::value> {};

   template<typename B, typename C>
   constexpr bool or_bool_v = or_bool<B,C>::value;

   template<typename B, typename C>
   using or_bool_t = typename or_bool<B,C>::type;


   /// not operator
   template<typename B>
   struct not_bool : bool_constant<!B::value> {};

   template<typename B>
   constexpr bool not_bool_v = not_bool<B>::value;

   template<typename B>
   using not_bool_t = typename not_bool<B>::type;


   /// add1
   template<typename N>
   struct add1 : int_constant<N::value + 1> {};

   template<typename N>
   constexpr int add1_v = add1<N>::value;

   template<typename N>
   using add1_t = typename add1<N>::type;


   /// eql
   template<typename N, typename M>
   struct eql : bool_constant<N::value == M::value> {};

   template<typename N, typename M>
   constexpr bool eql_v = eql<N,M>::value;

   template<typename N, typename M>
   using eql_t = typename eql<N,M>::type;


   /// mod operator
   template<typename A, typename B>
   struct mod : int_constant<A::value % B::value> {};

   template<typename A, typename B>
   constexpr int mod_v = mod<A,B>::value;

   template<typename A, typename B>
   using mod_t = typename mod<A,B>::type;


   /// isDivisor
   template<typename D, typename N>
   struct isDivisor : isZero<mod_t<N,D>> {};

   template<typename D, typename N>
   constexpr bool isDivisor_v = isDivisor<D,N>::value;

   template<typename D, typename N>
   using isDivisor_t = typename isDivisor<D,N>::type;


   /// hasDivisors
   template<typename D, typename N>
   struct hasDivisors_aux : or_bool<
							   isDivisor_t<D,N>,
							   typename hasDivisors_aux<add1_t<D>,N>::type> {};

   template<typename N>
   struct hasDivisors_aux<N,N> : bool_constant<false> {};

   template<typename N>
   struct hasDivisors : hasDivisors_aux<int_constant_t<2>,N> {};

   template<typename N>
   constexpr bool hasDivisors_v = hasDivisors<N>::value;

   template<typename N>
   using hasDivisors_t = typename hasDivisors<N>::type;


   /// isPrime
   template<typename N>
   struct isPrime : not_bool<hasDivisors_t<N>> {};

   template<typename N>
   constexpr bool isPrime_v = isPrime<N>::value;

   template<typename N>
   using isPrime_t = typename isPrime<N>::type;


   /// nextPrime
   template<typename N, typename IsPrime>
   struct nextPrimeAux : nextPrimeAux<add1_t<N>,isPrime_t<add1_t<N>>> {};

   template<typename N>
   struct nextPrimeAux<N,bool_constant_t<true>> : N {};

   template<typename N>
   struct nextPrime : nextPrimeAux<add1_t<N>,isPrime_t<add1_t<N>>> {};

   template<typename N>
   constexpr int nextPrime_v = nextPrime<N>::value;

   template<typename N>
   using nextPrime_t = typename nextPrime<N>::type;
 #+end_src

Vale, este código es duro de procesar. Pero nos quedamos al menos con la última, que nos permite obtener el siguiente número primo a partir de uno dado. Vamos a probarla.

 #+begin_src C++ :exports both :eval never-export :results output :includes "C:/Users/hecto/Documents/GitHub/lispylambda/posts/C++/prueba.h"
   std::cout << nextPrime_v<int_constant_t<13>> << std::endl;
 #+end_src 

 #+RESULTS:
 : 17

Todo esto está muy guay, pero falta algo. Con sólo tipos primitivos no conseguimos mucho. Vamos a ver si podemos crear algo más grande.

* Estructuras de datos
Al igual que existe ~std::integral_constant~, nosotros podemos crear nuevos tipos de datos usando estructuras de C++. Por ejemplo, supongamos que queremos crear en T++ un tipo de dato para representar vectores de dos coordenadas. En primer lugar debemos crear la estructura en C++.

 #+begin_src C++ :exports both :eval never-export :results output :includes "C:/Users/hecto/Documents/GitHub/lispylambda/posts/C++/prueba.h"
   struct vector{
	   int x;
	   int y;
   };
 #+end_src 

 En segundo lugar, creamos una función en T++ que cree el vector. Manteniendo la nomenclatura de los tipos primitivos, llamaremos a esta función ~vector_constant~.

 #+begin_src C++ :exports both :eval never-export :results output :includes "C:/Users/hecto/Documents/GitHub/lispylambda/posts/C++/prueba.h"
   template<int x, int y>
   struct vector_constant{
	   static constexpr vector value = {x,y};
	   using type = vector_constant;
   };
 #+end_src

 Observa que esta función tiene el atributo ~type~, que era obligatorio, además del atributo value que es el ~vector~ que hemos declarado justo antes.

Creamos también los templates ~_v~ y ~_t~.

 #+begin_src C++ :exports both :eval never-export :results output :includes "C:/Users/hecto/Documents/GitHub/lispylambda/posts/C++/prueba.h"
   template<int x, int y>
   constexpr vector vector_constant_v = vector_constant<x,y>::value;

   template<int x, int y>
   using vector_constant_t = typename vector_constant<x,y>::type;
 #+end_src

Para que sea más cómodo mostrar por pantalla un vector, vamos a sobrecargar el operador de extracción ~<<~.

 #+begin_src C++ :exports both :eval never-export :results output :includes "C:/Users/hecto/Documents/GitHub/lispylambda/posts/C++/prueba.h"
   std::ostream& operator<<(std::ostream& os, const vector& v){
	   os << "(" << v.x << "," << v.y << ")";
   }
 #+end_src

 Vamos a probar a imprimir un vector de T++.

 #+begin_src C++ :exports both :eval never-export :results output :includes "C:/Users/hecto/Documents/GitHub/lispylambda/posts/C++/prueba.h"
   std::cout << vector_constant_v<5,7> << std::endl;
 #+end_src

 #+RESULTS:
 : (5,7)
 
¡Perfecto!

Obviamente, la primera función que podemos hacer con un vector es el producto escalar de dos vectores. Aunque antes de hacerla creo que sería conveniente crear funciones para acceder a cada uno de los valores de un vector. Es decir, un par de ~getters~.

 #+begin_src C++ :exports both :eval never-export :results output :includes "C:/Users/hecto/Documents/GitHub/lispylambda/posts/C++/prueba.h"
   template<typename P>
   struct vector_x : int_constant<P::value.x> {};

   template<typename P>
   constexpr int vector_x_v = vector_x<P>::value;

   template<typename P>
   using vector_x_t = typename vector_x<P>::type;


   template<typename P>
   struct vector_y : int_constant<P::value.y> {};

   template<typename P>
   constexpr int vector_y_v = vector_y<P>::value;

   template<typename P>
   using vector_y_t = typename vector_y<P>::type;
 #+end_src

 Definimos también el producto de dos enteros.

 #+begin_src C++ :exports both :eval never-export :results output :includes "C:/Users/hecto/Documents/GitHub/lispylambda/posts/C++/prueba.h"
   template<typename N, typename M>
   struct mult : int_constant<N::value * M::value> {};

   template<typename N, typename M>
   constexpr int mult_v = mult<N,M>::value;

   template<typename N, typename M>
   using mult_t = typename mult<N,M>::type;
 #+end_src

 Ahora sí, el producto escalar.

 #+begin_src C++ :exports both :eval never-export :results output :includes "C:/Users/hecto/Documents/GitHub/lispylambda/posts/C++/prueba.h"
   template<typename P, typename Q>
   struct dot_product : add<
						   mult_t<
							   vector_x_t<P>,
							   vector_x_t<Q>>,
						   mult_t<
							   vector_y_t<P>,
							   vector_y_t<Q>>> {};

   template<typename P, typename Q>
   constexpr int dot_product_v = dot_product<P,Q>::value;

   template<typename P, typename Q>
   using dot_product_t = typename dot_product<P,Q>::type;
 #+end_src

Y lo probamos.

 #+begin_src C++ :exports both :eval never-export :results output :includes "C:/Users/hecto/Documents/GitHub/lispylambda/posts/C++/prueba.h"
   std::cout << dot_product_v<vector_constant_t<2,1>,vector_constant_t<3,5>> << std::endl;
 #+end_src

 #+RESULTS:
 : 11

* Arrays
Los arrays no tienen mucho misterio. Todo se define igual que con las estructuras, excepto algunos detalles. En primer lugar, vamos a utilizar templates variádicos. Es decir, un template que recibe una cantidad arbitraria de parámetros.

 #+begin_src C++ :exports both :eval never-export :results output :includes "C:/Users/hecto/Documents/GitHub/lispylambda/posts/C++/prueba.h"
   template<int... NS>
   struct int_array{
	   static constexpr int value[] = {NS...};
	   using type = int_array;
   };

   template<int... NS>
   constexpr int int_array_v[] = int_array<NS...>::value;

   template<int... NS>
   using int_array_t = typename int_array<NS...>::type;
 #+end_src

 #+begin_src
   error: initializer fails to determine size of 'int_array_v<NS ...>'
 #+end_src

¡Ups! ¿Qué ha pasado aquí? Parece que el compilador se queja cuando intentamos definir ~int_array_v~. El error nos indica que C++ no es capaz de deducir el tamaño del array. Podríamos intentar usar un puntero a ~value~ para evitar este error.

 #+begin_src C++ :exports both :eval never-export :results output :includes "C:/Users/hecto/Documents/GitHub/lispylambda/posts/C++/prueba.h"
   template<int... NS>
   constexpr int* int_array_v = int_array<NS...>::value;
 #+end_src

 #+begin_src
   error: invalid conversion from 'const int*' to 'int*'
 #+end_src

 Vale, a ver esto otro:

 #+begin_src C++ :exports both :eval never-export :results output :includes "C:/Users/hecto/Documents/GitHub/lispylambda/posts/C++/prueba.h"
   template<int... NS>
   constexpr const int* int_array_v = int_array<NS...>::value;
 #+end_src

Vale, esto compila. Vamos a probarlo.

 #+begin_src C++ :exports both :eval never-export :results output :includes "C:/Users/hecto/Documents/GitHub/lispylambda/posts/C++/prueba.h"
   std::cout << int_array_v<2,4,6>[1] << std::endl;
 #+end_src
 
 #+begin_src
   error: undefined reference to `int_array<2, 4, 6>::value'
 #+end_src

Una última prueba. Creo recordar que los arrays que son ~static constexpr~ tienen que estar definidos (además de estar declarados). Así que vamos a añadir lo siguiente:

 #+begin_src C++ :exports both :eval never-export :results output :includes "C:/Users/hecto/Documents/GitHub/lispylambda/posts/C++/prueba.h"
   template<int... NS>
   constexpr int int_array<NS...>::value[];
 #+end_src

 Probamos de nuevo...

  #+begin_src C++ :exports both :eval never-export :results output :includes "C:/Users/hecto/Documents/GitHub/lispylambda/posts/C++/prueba.h"
   std::cout << int_array_v<2,4,6>[1] << std::endl;
 #+end_src

 #+RESULTS:
 : 4
 
 ¡Sí, perfecto!

Antes de continuar, observa que cualquier otro array se definirá de la misma forma pero cambiando el tipo subyacente del array. En ese caso, podemos crear un array genérico en T++.

 #+begin_src C++ :exports both :eval never-export :results output :includes "C:/Users/hecto/Documents/GitHub/lispylambda/posts/C++/prueba.h"
   template<typename T, T... TS>
   struct integral_array{
	   static constexpr T value[] = {TS...};
	   using type = integral_array;
   };

   template<typename T, T... TS>
   constexpr T integral_array<T, TS...>::value[];

   template <typename T, T... TS>
   constexpr const T* integral_array_v = integral_array<T,TS...>::value;

   template<typename T, T... TS>
   using integral_array_t = typename integral_array<T,TS...>::type;
 #+end_src

Lo probamos:

 #+begin_src C++ :exports both :eval never-export :results output :includes "C:/Users/hecto/Documents/GitHub/lispylambda/posts/C++/prueba.h"
   std::cout << integral_array_v<int,1,5,10>[2] << std::endl;
 #+end_src

 #+RESULTS:
 : 10

 Podemos ahora redefinir los arrays de enteros a partir de estos arrays genéricos.

 #+begin_src C++ :exports both :eval never-export :results output :includes "C:/Users/hecto/Documents/GitHub/lispylambda/posts/C++/prueba.h"
   template<int... TS>
   struct int_array : integral_array<int,TS...> {};

   template <int... TS>
   constexpr const int* int_array_v = int_array<TS...>::value;

   template<int... TS>
   using int_array_t = typename int_array<TS...>::type;
 #+end_src

 Vamos a crear la función para poder acceder a los elementos del array. Al igual que con las estructuras, los valores devueltos por estas funciones van a ser tipos primitivos de T++, no de C++. La función para obtener un elemento de un array recibirá el array y un entero de T++ indicando el índice del elemento a devolver. Pero hay aún un problema por resolver. El array es de tipo genérico, así que no sabemos con certeza que tipo debemos devolver. Para ello vamos a crear un nuevo atributo en el array llamado ~value_type~. Este atributo también existe en el tipo ~std::integral_constant~ que hemos usado hasta ahora. Este atributo guarda su tipo subyacente. Para ~std::integral_constant<int,5>~, ~value_type~ vale ~int~. El array quedaría de la siguiente forma:

 #+begin_src C++ :exports both :eval never-export :results output :includes "C:/Users/hecto/Documents/GitHub/lispylambda/posts/C++/prueba.h"
   template<typename T, T... TS>
   struct integral_array{
	   static constexpr T value[] = {TS...};
	   using type = integral_array;
	   using value_type = T;
   };

   template<typename T, T... TS>
   constexpr T integral_array<T, TS...>::value[];

   template <typename T, T... TS>
   constexpr const T* integral_array_v = integral_array<T,TS...>::value;

   template<typename T, T... TS>
   using integral_array_t = typename integral_array<T,TS...>::type;
 #+end_src

 Ahora sí podemos hacer la función deseada.

 #+begin_src C++ :exports both :eval never-export :results output :includes "C:/Users/hecto/Documents/GitHub/lispylambda/posts/C++/prueba.h"
   template<typename A, typename N>
   struct aref
	   : std::integral_constant<typename A::value_type,A::value[N::value]> {};

   template<typename A, typename N>
   constexpr typename A::value_type aref_v = aref<A,N>::value;

   template<typename A, typename N>
   using aref_t = typename aref<A,N>::type;
 #+end_src

 La función ~aref~ va a devolver un ~std::integral_constant~. El valor subyacente de este valor tiene que ser el mismo que el del array, por eso usamos ~A::value_type~. Luego, con ~A::value[]~ accedemos a algún valor del array. El índice elegido es ~N::value~, que será un entero de T++.

 Por otro lado, observa cómo se crea ~aref_v~. Como el array es genérico, el único modo de saber el tipo a devolver es accediendo de nuevo a ~A::value_type~.

#+begin_src C++ :exports both :eval never-export :results output :includes "C:/Users/hecto/Documents/GitHub/lispylambda/posts/C++/prueba.h"
  using miArray = integral_array_t<int,1,1,2,3,5,8>;

  std::cout << aref_v<miArray,int_constant_t<5>> << std::endl;
 #+end_src

 #+RESULTS:
 : 8
 
Por mostrar alguna función usando los arrays, vamos a crear una que calcule la suma de todos los elementos de un array dado. Esta función recibirá un array de enteros, además del número de elementos a sumar.

#+begin_src C++ :exports both :eval never-export :results output :includes "C:/Users/hecto/Documents/GitHub/lispylambda/posts/C++/prueba.h"
  template<typename A, typename N>
  struct sum_array : add<
						  aref_t<A,sub1_t<N>>,
						  typename sum_array<A,sub1_t<N>>::type> {};

  template<typename A>
  struct sum_array<A,int_constant_t<0>> : int_constant_t<0> {};

  template<typename A, typename N>
  constexpr int sum_array_v = sum_array<A,N>::value;

  template<typename A, typename N>
  using sum_array_t = typename sum_array<A,N>::type;
 #+end_src

Para no complicar mucho la implementación de esta función, los elementos se van sumando de derecha a izquierda. Además, se ha usado la función ~sub1~ que habíamos definido antes. Es equivalente a ~add1~, pero en vez de sumar ~1~, resta ~1~.

Vamos a probarla.

#+begin_src C++ :exports both :eval never-export :results output :includes "C:/Users/hecto/Documents/GitHub/lispylambda/posts/C++/prueba.h"
  std::cout << sum_array_v<int_array_t<1,4,3>,int_constant_t<3>> << std::endl;
 #+end_src

 #+RESULTS:
 : 8

Perfecto.

Una pregunta obligatoria tras definir los arrays es, ¿y los strings?. Los strings son arrays de caracteres. Así que podríamos definir el tipo ~char_array~ para definir strings.

#+begin_src C++ :exports both :eval never-export :results output :includes "C:/Users/hecto/Documents/GitHub/lispylambda/posts/C++/prueba.h"
  template<char... cs>
  struct char_array : integral_array<char,cs...> {};

  template <char... cs>
  constexpr const char* char_array_v = char_array<cs...>::value;

  template<char... cs>
  using char_array_t = typename char_array<cs...>::type;
 #+end_src

Pero vamos a reflexionar un poco. Si pensamos en los arrays de caracteres de C o C++, éstos tienen una forma en particular cuando los inicializamos. Estoy hablando del caracter nulo que nos encontramos al final de cada string. Cuando inicializamos un string, C++ añade automáticamente un caracter adicional, el caracter nulo. Nosotros deberíamos hacer lo mismo. Para ello vamos a especializar ~integral_array~ para el tipo ~char~.

#+begin_src C++ :exports both :eval never-export :results output :includes "C:/Users/hecto/Documents/GitHub/lispylambda/posts/C++/prueba.h"
  template<char... TS>
  struct integral_array<char,TS...>{
	  static constexpr char value[] = {TS...,'\0'};
	  using type = integral_array;
	  using value_type = char;
  };
 #+end_src
 
 A pesar de esto, uno ya puede preveer que crear strings no va a ser muy cómodo, pues tendremos que pasar los caracteres uno a uno.

#+begin_src C++ :exports both :eval never-export :results output :includes "C:/Users/hecto/Documents/GitHub/lispylambda/posts/C++/prueba.h"
  using holaMundo = char_array_t<'H','o','l','a',' ','m','u','n','d','o','!'>;

  std::cout << holaMundo::value << std::endl;
 #+end_src 

 #+RESULTS:
 : Hola mundo!

Sin embargo, sí podemos crear una función que reciba un puntero a ~char~ y que devuelva un string de T++. Aunque hay que hacer algo de trabajo extra. Las siguientes funciones se salen un poco del objetivo de este trabajo, así que no las explicaré. He dejado un breve comentario indicando para qué sirven.

#+begin_src C++ :exports both :eval never-export :results output :includes "C:/Users/hecto/Documents/GitHub/lispylambda/posts/C++/prueba.h"
  /// int_collection
  /// define una coleccion de enteros
  template<int... ns>
  struct int_collection {
	  using type = int_collection;
  };

  template<int... ns>
  using int_collection_t = typename int_collection<ns...>::type;


  /// range_collection
  /// devuelve una coleccion de enteros de 0 a n
  template<int n, int... ns>
  struct range_collection_aux : range_collection_aux<n-1,n-1,ns...> {};

  template<int... ns>
  struct range_collection_aux<0,ns...> : int_collection<ns...> {};

  template<int n>
  struct range_collection : range_collection_aux<n> {};

  template<int n>
  using range_collection_t = typename range_collection<n>::type;


  /// aref_str
  /// devuelve el caracter de un string de C++ con indice i
  template<const char* str, int i>
  struct aref_str{
	  static constexpr char value = str[i];
  };

  template<const char* str, int i>
  constexpr char aref_str_v = aref_str<str,i>::value;


  /// length_str
  /// devuelve la longitud de un string de C++
  template<const char* str, int i, bool nullchar>
  struct length_str_aux : length_str_aux<str,i+1,str[i]=='\0'> {};

  template<const char* str, int i>
  struct length_str_aux<str,i,true>{
	  static constexpr int value = i;
  };

  template<const char* str>
  struct length_str : length_str_aux<str,0,str[0]=='\0'> {};

  template<const char* str>
  constexpr int length_str_v = length_str<str>::value;


  /// Crea un string de T++ a partir de uno de C++
  template<const char* str, typename C>
  struct make_string_aux {};

  template<const char* str, int... ns>
  struct make_string_aux<str,int_collection<ns...>> : integral_array<char,aref_str_v<str,ns>...> {};

  template<const char* str>
  struct make_string : make_string_aux<str,range_collection_t<length_str_v<str>>> {};

  template<const char* str>
  constexpr const char* make_string_v = make_string<str>::value;

  template<const char* str>
  using make_string_t = typename make_string<str>::type;
 #+end_src 

Para poder pasar un string como argumento de un template, necesitamos crear el string como una variable global ~constexpr~.

#+begin_src C++ :exports both :eval never-export :results output :includes "C:/Users/hecto/Documents/GitHub/lispylambda/posts/C++/prueba.h"
  constexpr char holaMundo[] = "Hola mundo!";
 #+end_src

 Lo probamos.

#+begin_src C++ :exports both :eval never-export :results output :includes "C:/Users/hecto/Documents/GitHub/lispylambda/posts/C++/prueba.h"
  std::cout << make_string_v<holaMundo> << std::endl;
 #+end_src

 #+RESULTS:
 : Hola mundo!
 
Y por si no convence mucho el ejemplo, vamos a utilizar la función ~aref~.

#+begin_src C++ :exports both :eval never-export :results output :includes "C:/Users/hecto/Documents/GitHub/lispylambda/posts/C++/prueba.h"
  std::cout << aref_v<make_string_t<holaMundo>,int_constant_t<5>> << std::endl;
 #+end_src

 #+RESULTS:
 : m

 Una última reflexión para cerrar esta sección, es si podríamos crear arrays de estructuras. Quizás sea posible, pero recuerda que en nuestro ejemplo la estructura debía recibir varios argumentos. En concreto, recibirá tantos argumentos como miembros tenga la estructura. En un array de estructuras, tendríamos que pasar todos los argumentos al mismo tiempo para todas las estructuras del array. Sólo de pensarlo me dan escalofríos. Mejor dejarlo aquí y continuar con otros tipos de contenedores que nos serán más útiles.

* Colecciones
Hasta ahora nos hemos centrado en valores primitivos y arrays de estos valores. Pero podemos crear también contenedores de tipos. Uno de estos contenedores los llamaremos colecciones. Aquí va la definición.

#+begin_src C++ :exports both :eval never-export :results output :includes "C:/Users/hecto/Documents/GitHub/lispylambda/posts/C++/prueba.h"
  template<typename... TS>
  struct collection{
	  using type = collection;
  };

  template<typename... TS>
  using collection_t = typename collection<TS...>::type;
 #+end_src

 Este template recibe una cantidad arbitraria de tipos y... no hace nada con ellos. El simple hecho de estar en la lista de argumentos nos permite 'almacenarlos'. Observa además que en este caso no tiene sentido un atributo ~value~, pues todos los argumentos son tipos que no tienen por qué representar ningún valor, ya sea numérico o de cualquier otro tipo.
 
Como ejemplo podemos crear una función que nos diga si una colección está o no vacía.

#+begin_src C++ :exports both :eval never-export :results output :includes "C:/Users/hecto/Documents/GitHub/lispylambda/posts/C++/prueba.h"
  template<typename C>
  struct is_empty {};

  template<typename T, typename... TS>
  struct is_empty<collection<T,TS...>> : bool_constant<false> {};

  template<typename... TS>
  struct is_empty<collection<TS...>> : bool_constant<true> {};

  template<typename C>
  constexpr bool is_empty_v = is_empty<C>::value;

  template<typename C>
  using is_empty_t = typename is_empty<C>::type;
 #+end_src

Observa que, como otras funciones que hemos implementado, se usa la especialización de templates. Pues fíjate en el caso general, es decir, la primera de todas. Es un struct vacío, no hereda de nadie ni tiene atributos. Al hacer esto, estamos forzando a que se genere un error si alguien usa esta función si no proporciona una colección como argumento.

Probamos la función.

#+begin_src C++ :exports both :eval never-export :results output :includes "C:/Users/hecto/Documents/GitHub/lispylambda/posts/C++/prueba.h"
  std::cout << is_empty_v<collection_t<>> << std::endl;
  std::cout << is_empty_v<collection_t<int,float,char>> << std::endl;
 #+end_src

 #+RESULTS:
 : 1
 : 0

Concatenar colecciones también es muy sencillo.

#+begin_src C++ :exports both :eval never-export :results output :includes "C:/Users/hecto/Documents/GitHub/lispylambda/posts/C++/prueba.h"
  template<typename C, typename D>
  struct concatenate {};

  template<typename... CS, typename... DS>
  struct concatenate<collection<CS...>,collection<DS...>> : collection<CS...,DS...> {};

  template<typename C,typename D>
  using concatenate_t = typename concatenate<C,D>::type;
 #+end_src

Y ahora es cuando tenemos el problema de que no podemos imprimir una colección de tipos. En algunos editores, pasando el ratón por encima de una directiva ~using~, es posible que veas el tipo resultante de aplicar estas funciones. Aunque también hay otro truquillo. Vamos a definir la estructura ~debug~ que nos permitirá ver el resultado de nuestras funciones cuando devuelvan tipos en lugar de valores.

#+begin_src C++ :exports both :eval never-export :results output :includes "C:/Users/hecto/Documents/GitHub/lispylambda/posts/C++/prueba.h"
  template<typename T>
  struct debug {};
 #+end_src

 Te estarás preguntando qué tiene de especial esta estructura para conseguir visualizar el resultado de nuestras funciones. La respuesta es nada. De hecho, puedes llamar a esta estructura como quieras. Lo que vamos a hacer es forzar un error intentando acceder a un miembro inexistente de la estructura ~debug~. Esto se ve mejor con un ejemplo.

#+begin_src C++ :exports both :eval never-export :results output :includes "C:/Users/hecto/Documents/GitHub/lispylambda/posts/C++/prueba.h"
  using foo = debug<concatenate_t<collection_t<int,float>,collection_t<char,double>>>::type;
 #+end_src

#+begin_src
  error: 'type' in 'struct debug<collection<int, float, char, double> >' does not name a type
 #+end_src
 
Vaya vaya. Así que no existe el atributo ~type~ en la estructura ~debug<collection<int,float,char,double>>~. Observa bien lo que hay escrito. Dentro de debug tenemos exactamente ~collection<int,float,char,double>~. Y está claro que esa es la concatenación de ~collection_t<int,float>~ y ~collection_t<char,double>~.

Sé que no es el método de debug más elegante, pero al menos funciona. Y si has pensado en usar la librería ~<typeinfo>~... no, no funciona. Aquí una prueba.

#+begin_src C++ :exports both :eval never-export :results output :includes '(<typeinfo> "C:/Users/hecto/Documents/GitHub/lispylambda/posts/C++/prueba.h")
  std::cout << typeid(concatenate_t<collection_t<int,float>,collection_t<char,double>>).name() << std::endl;
 #+end_src

 #+RESULTS:
 : 10collectionIJifcdEE

Yo la verdad es que no entiendo muy bien lo que pone ahí.

Vamos a detenernos de nuevo en la función concatenate.

#+begin_src C++ :exports both :eval never-export :results output :includes "C:/Users/hecto/Documents/GitHub/lispylambda/posts/C++/prueba.h"
  template<typename C, typename D>
  struct concatenate {};

  template<typename... CS, typename... DS>
  struct concatenate<collection<CS...>,collection<DS...>> : collection<CS...,DS...> {};

  template<typename C,typename D>
  using concatenate_t = typename concatenate<C,D>::type;
 #+end_src

 Observa la especialización de ~concatenate~. Fíjate en cómo estamos usando la especialización para darle un nombre a los elementos de cada colección. La primera colección tiene unos elementos que identificamos con ~CS~. Y para la segunda colección usamos el identificador ~DS~. Esta facilidad de darle un identificador a los elementos de una colección es lo que hace este tipo de contenedor sea tan útil para los templates de C++.

 Otro ejemplo interesante es la función para invertir el orden de los elementos de una colección.

#+begin_src C++ :exports both :eval never-export :results output :includes "C:/Users/hecto/Documents/GitHub/lispylambda/posts/C++/prueba.h"
  template<typename C, typename D>
  struct reverse_collection_aux {};

  template<typename... cs, typename... ds>
  struct reverse_collection_aux<collection<cs...>, collection<ds...>>
	  : collection_t<ds...> {};

  template<typename c, typename... cs, typename... ds>
  struct reverse_collection_aux<collection<c,cs...>, collection<ds...>>
	  : reverse_collection_aux<collection_t<cs...>, collection_t<c,ds...>> {};

  template<typename C>
  struct reverse_collection
	  : reverse_collection_aux<C, collection_t<>> {};

  template<typename C>
  using reverse_collection_t = typename reverse_collection<C>::type;
 #+end_src

 De nuevo, la especialización de los templates nos permite dar identificadores a los elementos de una colección, incluso a elementos concretos como en este caso, donde se le da el identificador ~c~ al primer elemento de la colección. Observa que la clave de esta función está en la segunda especialización, donde el elemento ~c~ pasa de la primera colección a la segunda. 

#+begin_src C++ :exports both :eval never-export :results output :includes "C:/Users/hecto/Documents/GitHub/lispylambda/posts/C++/prueba.h"
  using foo = debug<reverse_collection_t<collection_t<float,char,int>>>::type;
 #+end_src

#+begin_src
  error: 'type' in 'struct debug<collection<int, char, float> >' does not name a type
 #+end_src


 
 
 
 
 

 
