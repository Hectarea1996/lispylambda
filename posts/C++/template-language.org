#+TITLE: T++: El lenguaje oculto tras los Templates
#+date:<2023-07-30 do.>

Te propongo lo siguiente: Vamos a aprender un lenguaje de programación nuevo. Lo llamaremos *T++*. Es un lenguaje funcional puro, pero no te preocupes, iremos poco a poco si nunca te has enfrentado con algo así.

T++ es un lenguaje que se usa sobre C++. Por ello, podemos crear una función ~main~ común y corriente para poder comprobar el código que vayamos haciendo. Además, incluiremos una librería indispensable para poder usar T++: *type_traits*.

#+begin_src C++
  #include <iostream>
  #include <type_traits>

  // Aqui declararemos todas las funciones

  int main(){

          // Aquí porbaremos las funciones

          return 0;
  }
#+end_src

* Introducción
En T++ los protagonistas serán los tipos de datos. Todo van a ser tipos de datos. Da igual si estamos usando una constante o una función, éstos se representarán mediante tipos de datos de C++.

Sin embargo, para poder hacer cosas interesantes, la mayoría de tipos que usaremos estarán templatizados. En particular, haremos un uso extensivo de las conocidas meta-funciones.

Una meta-función es una estructura templatizada con, al menos, un atributo denominado ~type~. Este atributo es un tipo de dato que representará el resultado de la meta-función. Por ejemplo, podemos definir de la siguiente manera la meta-función identidad:

#+begin_src C++
template<typename T>
struct identity{
  using type = T;
};
#+end_src 

La forma de usar esta meta-función es sencilla:

#+begin_src C++ :exports both :eval never-export :results output :includes '(<iostream> </home/hectarea/lispylambda/posts/C++/prueba.h>)
identity<int>::type myInteger = 3;
std::cout << myInteger << std::endl;
#+end_src

#+RESULTS:
: 3

Observa cómo se está usando ~identity<int>::type~. La meta-función ~identity~ está recibiendo el argumento ~int~ que lo devuelve a través de ~type~.

Cuando usamos una meta-función de esta manera decimos que estamos *evaluando* la meta-función. Sólo queda decir que estas meta-funciones van a ser el núcleo de T++ y serán lo que nos permita hacer cosillas interesantes en tiempo de compilación.

* Constantes
Y sin esperar mucho más, vamos a definir cuáles van a ser las constantes en T++. Decimos que un tipo de C++ es una constante en T++ si es una meta-función que se evalúa a sí misma. Aunque parezca raro, esto se puede hacer sin problemas.

Empecemos por algo sencillo. Los enteros. Queremos crear un tipo de datos que represente, dependiendo de un argumento, a cada uno de los enteros. Como los templates pueden aceptar enteros, la solución es sencilla. Además, recuerda que se tiene que evaluar a sí misma:

#+begin_src C++
template<int n>
struct int_constant{
  using type = int_constant;
};
#+end_src

¡Hecho! Observa que la meta-función devuelve ~int_constant~. A priori, parece que no sea lo mismo que ~int_constant<n>~, pero para C++ sí lo es. Es una manera sencilla que tiene el lenguaje para indicar que queremos devolver el mismo tipo en el que nos encontramos.

Aunque aún falta algo. Para crear una meta-función como se merece tenemos que definir un alias para la evaluación. Esto permitirá más adelante escribir menos código. Este alias tiene el mismo nombre que la meta-función, pero además se le añade el sufijo ~_t~:

#+begin_src C++
template<int n>
using int_constant_t = typename int_constant<n>::type;
#+end_src

Este alias recibe exactamente los mismos argumentos que la meta-función y la evalúa. Observa que hemos tenido que añadir ~typename~. Esto es debido a que tenemos que indicarle al compilador que vamos a recibir un tipo de dato cuando usamos un argumento del template.

Y por ese ~typename~ es que creamos el alias. En lugar de usar

#+begin_src C++
typename int_constant<n>::type;
#+end_src

ahora sólo tenemos que escribir

#+begin_src C++
int_constant_t<n>;
#+end_src

Más cortito y ya no se nos olvidará ese dichoso ~typename~.

* Entre C++ y T++
Aunque hablemos principalmente de T++, el objetivo final es encontrar una manera de usar este nuevo lenguaje en perfecta armonía con C++. Para ello, vale la pena definir los puentes entre los dos lenguajes.

Vamos a observar de nuevo la definición de ~int_constant~:

#+begin_src C++
template<int n>
struct int_constant{
  using type = int_constant;
};
#+end_src

Observa que el argumento que recibe es un valor de C++. Por tanto, estamos ante un puente entre C++ y T++. Pero sólo va en una dirección: dado un valor de C++ conseguimos una constante de T++. También nos puede interesar el camino opuesto. Para ello, vamos a añadir un atributo extra que denominaremos ~value~. Este atributo simplemente tendrá el mismo valor que el argumento:

#+begin_src C++
template<int n>
struct int_constant{
  using type = int_constant;
  static constexpr int value = n;
};
#+end_src

Fíjate que hemos añadido ~static~ y ~constexpr~ a la declaración del atributo ~value~. Con ~static~ conseguimos que el atributo forme parte del struct y no de los objetos de tipo dicho struct. Y con ~constexpr~ conseguimos formar a que el valor de ~value~ esté disponible en tiempo de compilación.

Por último, al igual que con ~type~, nos interesa crear un alias:

#+begin_src C++
template<int n>
extern constexpr int int_constant_v = int_constant<n>::value;
#+end_src

Aquí ~constexpr~ sirve para lo mismo que con ~value~. Por otro lado, usamos ~extern~ para hacer que su tipo de lincado sea externo. De esta forma podemos poner la declaración en un header sin problemas.

Podemos comprobar si funciona:

#+begin_src C++ :exports both :eval never-export :results output :includes '(<iostream> </home/hectarea/lispylambda/posts/C++/prueba.h>)
std::cout << int_constant_v<5> << std::endl;
#+end_src

#+RESULTS:
: 5

Perfecto.

Pues ahora que sabemos cómo establecer un puente entre T++ y C++ basta crear una constante para cada tipo de C++. Es decir, podemos crear constantes para booleanos, floats, doubles. Aunque, ya que estamos, deberíamos hacerlo para int8_t, int16_t, unsigned int, uint8_t, uint32_t... ¡Ufff! ¡Qué pereza!

¿No podemos crear alguna constante que represente a cualquier valor de C++?

* La constante 'box'
Desde el estandar C++17 es válido indicar como argumento de un template un valor con el especificador ~auto~. De esta forma podemos conseguir definir una constante que represente un puente entre T++ y C++ para todos los valores primitivos de C++.

#+begin_src C++
template<auto b>
struct box{
  using type = box;
  static constexpr auto value = b; 
};

template<auto b>
using box_t = typename box<b>::type;

template<auto b>
extern constexpr auto box_v = box<b>::value;
#+end_src

Al igual que con ~int_constant~, definimos los atributos ~type~ y ~value~ así como los alias ~_t~ y ~_v~.

Vamos a probar:

#+begin_src C++ :exports both :eval never-export :results output :includes '(<iostream> </home/hectarea/lispylambda/posts/C++/prueba.h>)
std::cout << box_v<5> << std::endl;
std::cout << box_v<'k'> << std::endl;
#+end_src

#+RESULTS:
: 5
: k

¡Genial!

* Funciones
Una vez hemos visto las constantes necesitamos algo que nos permita hacer cálculos con ellos. Y ahí es cuando entran las funciones. Definimos las funciones en T++ a aquellas meta-funciones que se evalúan a una constante.

Por ejemplo, podemos definir una función que reciba dos enteros (~box<n>~ con ~n~ de tipo ~int~) y que devuelva la suma:

#+begin_src C++
template<typename A, typename B>
struct add2 : box<A::value + B::value>{};
#+end_src

Espera un momento... ¿Qué está pasando aquí? ¿Eso es una meta-función? ¿Dónde está el atributo ~type~?

Pues aunque parezca mentira, esto cumple perfectamente la definición de meta-función. Es más, es una función de T++ porque se evalúa a una constante, la constante ~box~. 

Observa cómo se ha definido la estructura ~add2~. En particular, fíjate en los '~:~' que hay tras ~add2~. ¡Estamos utilizando herencia! Es decir, estamos heredando de ~box~ y, por tanto, tenemos todos sus atributos. Y recordemos que ~box~ tenía dos atributos: ~type~ y ~value~.

En general, esta forma de definir funciones es 'la correcta'. Usaremos la herencia para definir funciones a no ser que no podamos por las características de la propia función.

Antes de continuar, no nos olvidemos de los alias:

#+begin_src C++
template<typename A, typename B>
using add2_t = typename add2<A,B>::type;

template<typename A, typename B>
extern constexpr auto add2_v = add2<A,B>::value;
#+end_src

Vamos a comprobar que funciona:

#+begin_src C++ :exports both :eval never-export :results output :includes '(<iostream> </home/hectarea/lispylambda/posts/C++/prueba.h>)
std::cout << add2_v<box<5>,box<10>> << std::endl;
#+end_src

#+RESULTS:
: 15

¡Espectacular!

La función de suma se puede generalizar para que acepte una cantidad variable de argumentos:

#+begin_src C++
template<typename... NS>
struct add : box<0>{};

template<typename N, typename... NS>
struct add<N,NS...> : box<N::value+add<NS...>::value> {};

template<typename... NS>
using add_t = typename add<NS...>::type;

template<typename... NS>
extern constexpr auto add_v = add<NS...>::value;
#+end_src

Lo probamos:

#+begin_src C++ :exports both :eval never-export :results output :includes '(<iostream> </home/hectarea/lispylambda/posts/C++/prueba.h>)
std::cout << add_v<box<1>, box<10>, box<9>, box<-100>> << std::endl;
#+end_src

#+RESULTS:
: -80

* Mucho texto...
Asumámoslo, definir una función en T++ requiere mucho texto. En particular, es bastante tedioso tener que escribir cada vez esas versiones cortas acabadas en ~_t~ o ~_v~. ¿Podemos ponerle algún remedio? Pues claro. Si no pudiésemos o no se me hubiese ocurrido nada, no existiría esta sección que estás leyendo. 

A pesar de no tener un buen sistema de macros como sí tienen los lenguajes de la familia Lisp (Common Lisp, Scheme, Clojure o Scheme, entro otros), de algo nos pueden servir en este caso. Y es que el simple hecho de tener el nombre de 'Macro' es una gran injusticia. El sistema de """"""Macros"""""" de C++ no le llega ni  a la suela de los zapatos a uno de verdad. Ahora que ya me he desahogado, podemos proseguir ~:D~.

Si nos fijamos en estas versiones cortas que hemos ido escribiendo, podemos ver algunos patrones que van a ser claves para crear una """"""Macro"""""" (vale, ya paro) que nos facilite un poco la vida. Veamos dos ejemplos:

#+begin_src C++ :exports both :eval never-export :results output :includes '(<iostream> "\"/home/hector/lispylambda/posts/C++/prueba.h\"")
   template<typename N, typename M>
   struct mult : box<N::value * M::value> {};

   template<typename N, typename M>
   using mult_t = typename mult<N,M>::type;  

   template<typename N, typename M>
   extern constexpr auto mult_v = mult<N,M>::value;
 #+end_src

#+begin_src C++ :exports both :eval never-export :results output :includes '(<iostream> "\"/home/hector/lispylambda/posts/C++/prueba.h\"")
template<typename T>
struct is_zero : box<false> {};

template<>
struct is_zero<box<0>> : bool_constant<true> {};

template<typename T>
using is_zero_t = typename is_zero<T>::type;

template<typename T>
extern constexpr auto is_zero_v = is_zero<T>::value;
 #+end_src

Observa, que a pesar de tener diferencias, la definición de las abreviaciones es bastante parecida en ambos casos. Si nos fijamos únicamente en dichas diferencias sabremos qué debe recibir nuestra macro. Es decir, nuestra macro recibirá esas partes que cambian de función a función.

Podemos apreciar ~3~ diferencias en total: El nombre de la función, la declaración de los argumentos de cada template y cómo se pasan dichos argumentos a la función. Por tanto, la macro podría ser de la siguiente manera:

#+begin_src C++ :exports both :eval never-export :results output :includes '(<iostream> "\"~/lispylambda/posts/C++/prueba.h\"")
#define canonize(name, tempArg, call)      \
  tempArgs                                              \
  using name##_t = typename call##::type;               \
                                                        \
  tempArgs                                              \
  extern constexpr auto name##_v = call##::value;
 #+end_src

Y podríamos usarla de la siguiente manera...

#+begin_src C++ :exports both :eval never-export :results output :includes '(<iostream> </home/hectarea/lispylambda/posts/C++/prueba.h>)
canonize(mult, template<typename N, typename M>, mult<N,M>);
 #+end_src

 #+begin_src
 error: macro "canonize" passed 5 arguments, but takes just 3
 #+end_src
 
...si no fuese por las comas entre los argumentos de los templates. ¡Pero no nos rendimos! Además, ¡esta sección existe! ¡debe ser posible! ... ¿verdad?

A ver, busquemos en [[https://en.cppreference.com/w/cpp/preprocessor/replace][cppreference]]: ~Note: if an argument of a function-like macro includes commas that are not protected by matched pairs of left and right parentheses (most commonly found in template argument lists, as in assert(std::is_same_v<int, int>); or BOOST_FOREACH(std::pair<int, int> p, m)), the comma is interpreted as macro argument separator, causing a compilation failure due to argument count mismatch.~

¡Bien! Es lo que nos está ocurriendo y además nos dice cómo podemos solucionarlo. De alguna manera tenemos que introducir las comas entre paréntesis. Pero de alguna manera tenemos que eliminarlos después de que se expanda la macro. ¡Ya sé! Podemos poner dicho argumento entre paréntesis justo al lado de una macro. De esta forma, se ejecutará dicha macro que devolverá el argumento que está recibiendo. Sé que me explico fatal. Por lo que veamos paso a paso cómo hacerlo.

1. Primero definimos la macro ~EXPAND~. Recibe un argumento y lo devuelve, sin más:

#+begin_src C++ :exports both :eval never-export :results output :includes '(<iostream> </home/hectarea/lispylambda/posts/C++/prueba.h>)
#define EXPAND(X) X
 #+end_src

Ahora, sólo tenemos que cambiar ~canonize~ introduciendo una llamada a ~EXPAND~ cada vez que usemos un argumento:

#+begin_src C++ :exports both :eval never-export :results output :includes '(<iostream> "\"~/lispylambda/posts/C++/prueba.h\"")
#define EXPAND(X) X
#define canonize(name, tempArgs, call)                      \
  EXPAND tempArgs                                                       \
  using name##_t = typename EXPAND call ::type;                         \
                                                                        \
  EXPAND tempArgs                                                       \
  extern constexpr auto name##_v = EXPAND call ::value;
 #+end_src

El único argumento que no necesita ~EXPAND~ es ~name~, pues nunca podrá tener una coma al tener que referirse siempre al nombre de una función.

Probemos de nuevo:

#+begin_src C++ :exports both :eval never-export :results output :includes '(<iostream> "\"~/lispylambda/posts/C++/prueba.h\"")
canonize(mult, (template<typename N, typename M>), (mult<N,M>));
 #+end_src

Veamos si funciona:

#+begin_src C++ :exports both :eval never-export :results output :includes '(<iostream> </home/hectarea/lispylambda/posts/C++/prueba.h>)
std::cout << mult_v<box<3>,box<4>> << std::endl;
 #+end_src

 #+RESULTS:
 : 12

¡Perfecto! Ya te dije que esta sección estaba aquí por algo.

Pero podemos hacerlo mejor. Observa el segundo argumento que le pasamos a ~canonize~. Siempre le vamos a pasar la palabra ~template~ al inicio, además de los símbolos ~<~ y ~>~. Por otro lado, en el tercer argumento ocurre algo parecido, siempre vamos a utilizar el nombre de la función para realizar la llamada, pero dicho nombre ya lo estamos recibiendo como primer argumento. Cambiemos un poco la definición:

#+begin_src C++ :exports both :eval never-export :results output :includes '(<iostream> "\"~/lispylambda/posts/C++/prueba.h\"")
#define EXPAND(X) X
#define canonize(name, tempArgs, call)                      \
  template<EXPAND tempArgs>                                                       \
  using name##_t = typename name<EXPAND call> ::type;                         \
                                                                        \
  EXPAND tempArgs                                                       \
  extern constexpr auto name##_v = name<EXPAND call> ::value;
 #+end_src

Su uso quedaria ahora de la siguiente manera:

#+begin_src C++ :exports both :eval never-export :results output :includes '(<iostream> "\"~/lispylambda/posts/C++/prueba.h\"")
canonize(first, (typename C), (C));
 #+end_src

La nueva versión se utilizaría así:

#+begin_src C++ :exports both :eval never-export :results output :includes '(<iostream> "\"~/lispylambda/posts/C++/prueba.h\"")
canonize(mult, (typename N, typename M), (N,M));
 #+end_src

Bastante más cómodo que antes.

¡Pero podemos hacerlo aún mejor! Los argumentos de nuestros templates siempre van a ser tipos. Podemos hacer que todos los templates reciban siempre una cantidad variable de argumentos. Esto es válido, pues hasta que no se use un template, éste no se instancia y C++ no sabrá hasta entonces si la cantidad de argumentos que se ha pasado es correcta o no. Cambiemos de nuevo la definición.

#+begin_src C++ :exports both :eval never-export :results output :includes '(<iostream> "\"~/lispylambda/posts/C++/prueba.h\"")
#define EXPAND(X) X
#define canonize(name)                                  \
  template<typename... TS>                              \
  using name##_t = typename name<TS...> ::type;         \
                                                        \
  template<typename... TS>                              \
  extern constexpr auto name##_v = name<TS...> ::value;
 #+end_src

Espera un momento... Nos hemos quedado con... ¡¿sólo un argumento?! ¡Genial!

#+begin_src C++ :exports both :eval never-export :results output :includes '(<iostream> "\"~/lispylambda/posts/C++/prueba.h\"")
canonize(mult);
 #+end_src

Crear ahora estas abreviaciones es ¡demasiado fácil! ¡Pero funciona!

Lo mejor de todo, es que si en un futuro no muy lejano se nos ocurre añadir alguna nueva abreviación, sólo tendremos que añadirla a nuestra macro, y automáticamente ¡todas nuestras funciones tendrán esa nueva abreviación! 

Vamos a cambiar las definiciones de la función ~identity~ y la función ~add~ para que usen ~canonize~:

#+begin_src C++
/// identity
template<typename T>
struct identity : T {};

canonize(identity);

/// add
template<typename... NS>
struct add : box<0>{};

template<typename N, typename... NS>
struct add<N,NS...> : box<N::value+add<NS...>::value> {};

canonize(add);
#+end_src

Oh si... Mucho más limpio.

También ha aparecido la función ~mult~ que podemos generalizar para que reciba una cantidad variable de argumentos, así como la función ~is_zero~:

#+begin_src C++
/// mult
template<typename... NS>
struct mult : box<1> {};

template<typename N, typename... NS>
struct mult<N,NS...> : box<N::value * mult<NS...>::value> {};

canonize(mult);

/// is_zero
template<typename T>
struct is_zero : box<false>{}; 

template<>
struct is_zero<box<0>> : box<true> {};

canonize(is_zero);
#+end_src

* La constante 'tbox'
La constante 'box' introducida al inicio nos permitía tener una constante que además nos sirve de puente entre C++ y T++. Además, hemos dicho que una constante en T++ es una meta-función que se evalúa a sí misma. Pero también existen tipos en C++ que ni siquiera son meta-funciones. Hablamos de tipos como ~int~ o ~float~. Estos tipos también pertenecen a C++ y no a T++. Por lo que nos va a interesar crear otro puente.

Aquí definimos la constante de T++ ~tbox~. Va a funcionar igual que ~box~, pero en lugar de recibir un valor, recibimos un tipo de C++. 

Recibir como argumento este tipo de C++ es el puente que va de C++ hacia T++, pero tenemos que decidir cómo definimos el puente en la dirección opuesta. Aquí no podemos usar ~value~, porque ~value~ debe devolver siempre un valor, no un tipo. En este caso, usaremos ~value_type~. El propio atributo nos dice que va a ser un tipo con el uso de ​~_​type~, pero que además pertenece a C++ con el uso de ~value_~. 

#+begin_src C++
template<typename T>
struct tbox{
  using type = tbox;
  using value_type = T;
};
#+end_src

Como hemos estado haciendo hasta ahora, creamos varios alias para poder acceder directamente a estos atributos. Para el caso de ~value_type~ usamos ~_vt~:

#+begin_src C++
template<typename T>
using tbox_t = typename tbox<T>::type;

template<typename T>
using tbox_vt = typename tbox<T>::value_type;
#+end_src

Recordemos por un momento la definición de ~box~:

#+begin_src C++
template<auto b>
struct box{
  using type = box;
  static constexpr auto value = b; 
};

template<auto b>
using box_t = typename box<b>::type;

template<auto b>
extern constexpr auto box_v = box<b>::value;
#+end_src

Ahora que vamos a usar ~value_type~, podemos agregarlo a la constante ~box~ para poder obtener el tipo del valor almacenado. La definición quedaría así:

#+begin_src C++
template<auto b>
struct box{
  using type = box;
  using value_type = decltype(b);
  static constexpr auto value = b; 
};
#+end_src

Y su nuevo alias:

#+begin_src C++
template<auto b>
using box_vt = typename box<b>::value_type;
#+end_src

Pero esto no termina aquí. Ahora que tenemos un nuevo posible alias en nuestras constantes, nos gustaría que las funciones de T++ que definamos a continuación tuviesen también este nuevo alias. Pero recordemos que ahora disponemos de ~canonize~. Podemos añadir este nuevo alias en la macro y todas las definiciones pasadas y futuras tendrán automáticamente este alias disponible. La nueva definición de ~canonize~ queda así:

#+begin_src C++
#define canonize(name)                                  \
  template<typename... TS>                              \
  using name##_t = typename name<TS...> ::type;         \
                                                        \
  template<typename... TS>                              \
  static constexpr auto name##_v = name<TS...> ::value; \
                                                        \
  template<typename... TS>                              \
  using name##_vt = typename name<TS...>::value_type;
#+end_src

Podemos probar:

#+begin_src C++ :exports both :eval never-export :results output :includes '(<iostream> </home/hectarea/lispylambda/posts/C++/prueba.h>)
add_vt<box<3>,box<5>> miVar = 4; // add_vt devuelve un tipo
std::cout << miVar << std::endl;
#+end_src

#+RESULTS:
: 4

* Más funciones
Para avanzar un poco más mostramos a continuación una batería de funciones que nos podrían ser útiles más adelante. No tienen mucho misterio e iba a 'dejar como ejercicio al lector' el revisarlos y entenderlos. Siempre me ha dado mucha rabia esa frase. Por eso, en lugar de 'dejar como ejercicio al lector entender por sí mismo las funciones', diré simplemente que no las voy a explicar. ~:D~

 #+begin_src C++
// sub
template<typename... NS>
struct sub : box<0>{};

template<typename N, typename... NS>
struct sub<N,NS...> : box<N::value-sub<NS...>::value> {};

canonize(sub);


/// quotient
template<typename... NS>
struct quotient : box<1> {};

template<typename N, typename... NS>
struct quotient<N,NS...> : box<N::value / quotient<NS...>::value> {};

canonize(quotient);

/// or_logic
template<typename... NS>
struct or_logic : box<false>{};

template<typename N, typename... NS>
struct or_logic<N,NS...> : box<N::value || or_logic<NS...>::value> {};

canonize(or_logic);


/// and_logic
template<typename... NS>
struct and_logic : box<true>{};

template<typename N, typename... NS>
struct and_logic<N,NS...> : box<N::value && and_logic<NS...>::value> {};

canonize(and_logic);


/// not operator
template<typename B>
struct not_logic : box<!B::value> {};

canonize(not_logic);


/// add1
template<typename N>
struct add1 : box<N::value + 1> {};

canonize(add1);


/// sub1
template<typename N>
struct sub1 : box<N::value - 1> {};

canonize(sub1);


/// eql
template<typename N, typename M>
struct eql : box<N::value == M::value> {};

canonize(eql);
 #+end_src

Todo esto está muy guay, pero falta algo. Con sólo constantes de tipos primitivos no conseguimos mucho. Vamos a ver si podemos crear algo más grande.

* Colecciones
Hasta ahora nos hemos centrado en constantes y funciones que manipulan estas constantes simples. Pero podemos crear también contenedores de constantes. A continuación definimos las colecciones que, a pesar de contener constantes, ellas por sí mismas también son constantes.

#+begin_src C++
template<typename... TS>
struct collection{
  using type = collection;
};

template<typename... TS>
using collection_t = typename collection<TS...>::type;
#+end_src

Como ejemplo podemos crear una función que nos diga si una colección está o no vacía.

#+begin_src C++
template<typename C>
struct is_empty {};

template<typename... TS>
struct is_empty<collection<TS...>> : bool_constant<true> {};

template<typename T, typename... TS>
struct is_empty<collection<T,TS...>> : bool_constant<false> {};

canonize(is_empty);
#+end_src

Probamos la función.

#+begin_src C++ :exports both :eval never-export :results output :includes '(<iostream> </home/hectarea/lispylambda/posts/C++/prueba.h>)
  std::cout << is_empty_v<collection<>> << std::endl;
  std::cout << is_empty_v<collection<tbox<int>,tbox<float>,tbox<char>>> << std::endl;
#+end_src

#+RESULTS:
: 1
: 0

Ptra función sencilla es la que nos permite añadir un elemento al principio:

#+begin_src C++
template<typename V, typename C>
struct cons {};

template<typename V, typename... CS>
struct cons<V, collection<CS...>> : collection<V,CS...> {};

canonize(cons);
#+end_src

Otras funciones imprescindibles son las que nos permiten obtener o eliminar el primer elemento de una colección:

#+begin_src C++
/// car
template<typename C>
struct car {};

template<typename C, typename... CS>
struct car<collection<C,CS...>> : C {};

canonize(car);

/// cdr
template<typename C>
struct cdr {};

template<typename C, typename... CS>
struct cdr<collection<C,CS...>> : collection<CS...> {};

template<typename... CS>
struct cdr<collection<CS...>> : collection<CS...> {};

canonize(cdr);
#+end_src

Los nombres de estas funciones se han mantenido durante años por motivos históricos. Pero pienso que si se han mantenido es por su utilidad. Y cuando me refiero a su utilidad, no me refiero por sí solas, si no combinadas. Por ejemplo, si queremos obtener el segundo elemento de una colección, tenemos que usar primero ~cdr~ y luego ~car~. Esto resultaría en algo como así: ~car_t<cdr_t<collection<...>>>~. Pero este tipo de operaciones son tan comunes que se les da su propio nombre. La forma de generar estas combinaciones es empezando por ~c~, acabando por ~r~ y añadiendo por en medio una combinación de ~a~ y ~d~.

En el caso de ~car_t<cdr_t<...>>~ podemos definir la función ~cadr~. Si quisiésemos una función para ~cdr_t<car_t<cdr_t<cdr_t<...>>>>~ la llamaríamos ~cdaddr~. Claro que definir todas las combinaciones es imposible. Además, por cada ~a~ o ~d~ adicional que queramos añadir, la cantidad de combinaciones aumenta exponencialmente. En concreto, el número de funciones de hasta ~n~ letras (~a~ o ~d~) que habría que definir sería de ~2^(n+1) - 2~. La cantidad de funciones a definir de hasta 4 letras sería de ~2^5 - 2=30~. De hasta 3 letras: ~2^4-2=14~. De hasta 2 letras: ~6~.

Por motivos obvios (la pereza), vamos las funciones que quedan de hasta dos letras. Como ya tenemos los de 1 letra, quedan 4:

#+begin_src C++
/// caar
template<typename C>
struct caar : car<car_t<C>> {};

canonize(caar);

/// cadr
template<typename C>
struct cadr : car<cdr_t<C>> {};

canonize(cadr);

/// cdar
template<typename C>
struct cdar : cdr<car_t<C>> {};

canonize(cdar);

/// cddr
template<typename C>
struct cddr : cdr<cdr_t<C>> {};

canonize(cddr);
#+end_src

Pasemos a concatenar colecciones. La función es también relativamente sencilla:

#+begin_src C++ :exports both :eval never-export :results output :includes '(<iostream> "\"/home/hector/lispylambda/posts/C++/prueba.h\"")
template<typename C, typename D>
struct concat {};

template<typename... CS, typename... DS>
struct concat<collection<CS...>,collection<DS...>> : collection<CS...,DS...> {};

canonize(concat);
 #+end_src

Antes de continuar, tenemos que reflexionar sobre algo. Las funciones se van a ir complicando y necesitamos alguna forma de comprobar si son correctas. Al menos, queremos poder probarlas e imprimir un resultado. Pero ahora es cuando tenemos el problema de que no podemos imprimir un tipo. En algunos editores, pasando el ratón por encima de una directiva ~using~, es posible que veas el tipo resultante de aplicar estas funciones. Aunque también hay otro truquillo. Vamos a definir la estructura ~debug~ que nos permitirá ver el resultado de nuestras funciones.

#+begin_src C++ :exports both :eval never-export :results output :includes '(<iostream> "\"/home/hector/lispylambda/posts/C++/prueba.h\"")
  template<typename T>
  struct debug {};
 #+end_src

 Te estarás preguntando qué tiene de especial esta estructura para conseguir visualizar el resultado de nuestras funciones. La respuesta es nada. De hecho, puedes llamar a esta estructura como quieras. Lo que vamos a hacer es forzar un error intentando acceder a un miembro inexistente de la estructura ~debug~. Esto se ve mejor con un ejemplo.

#+begin_src C++ :exports both :eval never-export :results output :includes '(<iostream> </home/hectarea/lispylambda/posts/C++/prueba.h>)
  using foo = debug<concat_t<collection<tbox<int>,tbox<float>>,collection<tbox<char>,tbox<double>>>>::type;
#+end_src

#+begin_src
 error: ‘type’ in ‘struct debug<collection<tbox<int>, tbox<float>, tbox<char>, tbox<double> > >’ does not name a type
 #+end_src
 
Vaya vaya. Así que no existe el atributo ~type~ en la estructura ~debug<collection<tbox<int>,tbox<float>,tbox<char>,tbox<double>>>~. Observa bien lo que hay escrito. Dentro de debug tenemos exactamente ~collection<tbox<int>,tbox<float>,tbox<char>,tbox<double>>~. Y está claro que esa es la concatenación de ~collection<tbox<int>,tbox<float>>~ y ~collection<tbox<char>,tbox<double>>~.

Sé que no es el método de debug más elegante, pero al menos funciona. Y si has pensado en usar la librería ~<typeinfo>~... no, no funciona. Aquí una prueba.

#+begin_src C++ :exports both :eval never-export :results output :includes '(<iostream> </home/hectarea/lispylambda/posts/C++/prueba.h>)
std::cout << typeid(concat_t<collection<tbox<int>,tbox<float>>,collection<tbox<char>,tbox<double>>>).name() << std::endl;
#+end_src

#+RESULTS:
: 10collectionIJ4tboxIiES0_IfES0_IcES0_IdEEE

Yo la verdad es que no entiendo muy bien lo que pone ahí.

Vamos a detenernos de nuevo en la función ~concat~.

#+begin_src C++ :exports both :eval never-export :results output :includes '(<iostream> "\"/home/hector/lispylambda/posts/C++/prueba.h\"")
template<typename C, typename D>
struct concat {};

template<typename... CS, typename... DS>
struct concat<collection<CS...>,collection<DS...>> : collection<CS...,DS...> {};

canonize(concat);
 #+end_src

Observa la especialización de ~concat~. Fíjate en cómo estamos usando la especialización para darle un nombre a los elementos de cada colección. La primera colección tiene unos elementos que identificamos con ~CS~. Y para la segunda colección usamos el identificador ~DS~. Esta facilidad de darle un identificador a los elementos de una colección es lo que hace que este tipo de contenedor sea tan útil para los templates de C++.

 Otro ejemplo interesante es la función para invertir el orden de los elementos de una colección.

#+begin_src C++ :exports both :eval never-export :results output :includes '(<iostream> "\"/home/hector/lispylambda/posts/C++/prueba.h\"")
template<typename C, typename D>
struct reverse_collection_aux {};

template<typename... cs, typename... ds>
struct reverse_collection_aux<collection<cs...>, collection<ds...>>
	: collection<ds...> {};

template<typename c, typename... cs, typename... ds>
struct reverse_collection_aux<collection<c,cs...>, collection<ds...>>
	: reverse_collection_aux<collection<cs...>, collection<c,ds...>> {};

template<typename C>
struct reverse {};

template<typename... cs>
struct reverse<collection<cs...>> : reverse_collection_aux<collection<cs...>, collection<>> {};

canonize(reverse);
 #+end_src

 De nuevo, la especialización de los templates nos permite dar identificadores a los elementos de una colección, incluso a elementos concretos como en este caso, donde se le da el identificador ~c~ al primer elemento de la colección. Observa que la clave de esta función está en la segunda especialización de ~reverse_collection_aux~, donde el elemento ~c~ pasa de la primera colección a la segunda.

#+begin_src C++ :exports both :eval never-export :results output :includes '(<iostream> </home/hectarea/lispylambda/posts/C++/prueba.h>)
using foo = debug<reverse_t<collection<tbox<float>,tbox<char>,tbox<int>>>>::type;
#+end_src

#+begin_src
error: ‘type’ in ‘struct debug<collection<tbox<int>, tbox<char>, tbox<float> > >’ does not name a type
 #+end_src

Podríamos seguir definiendo funciones para las colecciones, pero sería mejor si llevásemos todo esto un poco más lejos. El objetivo es poder definir funciones de T++ que reciban otras funciones. Es decir, queremos una constante de T++ que represente a una función.

* Funciones de primera clase
En cualquier lenguaje funcional, las funciones son elementos de primera clase. Tienen su propio tipo y no los hace ni más ni menos especiales que cualquier otro tipo de dato. Sin embargo, en T++, las constantes y las funciones se deben de tratar de diferente manera. Basta ver las diferencias entre un entero ~box<5>~ y la función ~add~. Al definir un entero en T++, estamos definiendo una estructura en C++. Sin embargo, la función ~add~ es una estructura templatizada, y a menos que le proporcionemos los argumentos necesarios, no será una estructura como tal. Todo esto se puede apreciar mejor cuando intentamos crear una función que acepte cada uno de los dos tipos de argumentos.

Esta sería la posible implementación de una función que puede recibir como argumento una función como ~add2~ (la versión de ~add~ que recibía 2 argumentos).

#+begin_src C++ :exports both :eval never-export :results output :includes '(<iostream> "\"/home/hector/lispylambda/posts/C++/prueba.h\"")
  template<template<typename,typename> typename F>
  struct receiving_function : ... {};
 #+end_src

Y otra que recibiría un entero:

#+begin_src C++ :exports both :eval never-export :results output :includes '(<iostream> "\"/home/hector/lispylambda/posts/C++/prueba.h\"")
  template<typename I>
  struct receiving_integer : ... {};
 #+end_src

Es clara la diferencia. Mientras que en una debemos recibir un ~template<template<typename,typename> typename>~, en la otra recibimos ~template<typename>~.

Lo ideal sería tener un tipo de dato que nos permita manejar funciones al igual que los enteros. De esta forma podremos tener colecciones de funciones, por ejemplo.

Pues manos a la obra. Como no podemos predecir cuántos argumentos podrá recibir una función, podemos indicar que nuestro tipo de dato aceptará funciones con cualquier número de argumentos.

También necesitaremos un atributo extra que nos permita ejecutar la función. Dicho atributo lo llamaremos ~call~.

#+begin_src C++ :exports both :eval never-export :results output :includes '(<iostream> "\"/home/hector/lispylambda/posts/C++/prueba.h\"")
  template<template<typename...> typename F>
  struct function{
	using type = function;

	template<typename... A>
	using call = typename F<A...>::type;
  };
 #+end_src

Observa que ~call~ es un atributo templatizado. Simplemente recibe los argumentos que tiene que pasarle a la función ~F~.

Crear ahora un objeto de tipo ~function~ es muy sencillo. Por ejemplo, si queremos almacenar la función ~add~, basta usar ~function<add>~. De hecho, algo que deberíamos hacer a partir de ahora, es añadir un nuevo alias cada vez que creemos una función nueva. Por ejemplo, para ~add~ deberíamos añadir lo siguiente:

#+begin_src C++ :exports both :eval never-export :results output :includes '(<iostream> "\"/home/hector/lispylambda/posts/C++/prueba.h\"")
  using add_f = function<add>;
 #+end_src

Pero espera un momento... Si tenemos ~canonize~. Vamos a modificar la macro para que también añada este nuevo alias.

#+begin_src C++
#define canonize(name)                                  \
  template<typename... TS>                              \
  using name##_t = typename name<TS...> ::type;         \
                                                        \
  template<typename... TS>                              \
  static constexpr auto name##_v = name<TS...> ::value; \
                                                        \
  template<typename... TS>                              \
  using name##_vt = typename name<TS...>::value_type;   \
                                                        \
  using name##_f = function<name>;
#+end_src

Ahora necesitamos una función que pueda ejecutar una constante ~function~. La llamaremos ~funcall~.

#+begin_src C++
template<typename F, typename... A>
struct funcall : F::template call<A...> {};

canonize(funcall);
#+end_src

En lugar de acceder al atributo templatizado ~call~ cada vez que queramos ejecutar una función, usaremos la función ~funcall~. Esta función recibe una constante ~function~ y sus argumentos. Devolverá el resultado de ejecutar la función con esos argumentos.

#+begin_src C++ :exports both :eval never-export :results output :includes '(<iostream> "\"/home/hector/lispylambda/posts/C++/prueba.h\"")
  std::cout << funcall_v<add_f,box<5>,box<6>> << std::endl;
 #+end_src

 #+RESULTS:
 : 11
 
Otra función parecida a ~funcall~ es ~apply~. La diferencia está en que el último argumento debe ser una colección de argumentos. De esta forma, la función pasada a ~apply~ es ejecutada con los primeros argumentos pasados más los encontrados en la colección del último argumento.

#+begin_src C++
template<typename F, typename C, typename... A>
struct apply_aux {};

template<typename F, typename... CS, typename A, typename B, typename... AS>
struct apply_aux<F,collection<CS...>,A,B,AS...> : apply_aux<F,collection<CS...,A>,B,AS...> {};

template<typename F, typename... CS, typename... AS>
struct apply_aux<F,collection<CS...>,collection<AS...>> : funcall<F,CS...,AS...> {};

template<typename F, typename... A>
struct apply : apply_aux<F,collection<>,A...> {};

canonize(apply);
#+end_src

Como no podemos obtener directamente el último argumento de una colección, debemos ir guardando cada uno de los argumentos anteriores hasta que sepamos que sólo nos queda uno (el último). En ese momento, ejecutamos la función usando ~funcall~.

Para probarla, podemos definir una nueva función que sume todos los enteros de una colección. Sin ~apply~, necesitaríamos extraer los elementos de la colección mediante una especialización para luego llamar a ~add~. 

#+begin_src C++
template<typename C>
struct sum : apply<add_f,C> {};

canonize(sum);
#+end_src

Demasiado fácil para ser verdad. Pero funciona.

#+begin_src C++ :exports both :eval never-export :results output :includes '(<iostream> </home/hectarea/lispylambda/posts/C++/prueba.h>)
std::cout << sum_v<collection<box<1>,box<2>,box<3>>> << std::endl;
#+end_src

#+RESULTS:
: 6

* Más colecciones

Las colecciones son bastante útiles y por eso vale la pena seguir definiendo funciones que nos permitan manipularlas con facilidad. Por ahora tenemos ~is_empty~, ~concatenate~, ~reverse_collection~ y ~first~. Vamos a intentar definir aquellas que son básicas, aquellas que nos permitan contar elementos, generar nuevas colecciones, etc.

Una función que es bastante común es ~range~. Recibe un entero y devuelve una colección con todos los números no negativos menores que él.

#+begin_src C++ :exports both :eval never-export :results output :includes '(<iostream> </home/hectarea/lispylambda/posts/C++/prueba.h>)
template<typename N, typename I>
struct range_aux {};

template<int k>
struct range_aux<int_constant<k>,int_constant<k>> : collection<> {};

template<int n, int i>
struct range_aux<int_constant<n>, int_constant<i>>
  : cons<int_constant<n>, typename range_aux<int_constant<n+1>, int_constant<i>>::type> {};

template<typename I>
struct range : range_aux<int_constant<0>, I> {};

canonize(range);
 #+end_src

Ahora podemos, por ejemplo, calcular la suma de los 100 primeros números naturales:

#+begin_src C++ :exports both :eval never-export :results output :includes '(<iostream> </home/hectarea/lispylambda/posts/C++/prueba.h>)
std::cout << sum_v<range_t<box<101>>> << std::endl;
 #+end_src

 #+RESULTS:
 : 5050

Otra función más: ~length~. Creo que no es necesario ni explicar qué va a hacer.

#+begin_src C++
template<typename C>
struct length {};

template<>
struct length<collection<>> : box<0> {};

template<typename C, typename... CS>
struct length<collection<C,CS...>> : add1<typename length<collection<CS...>>::type> {};

canonize(length);
#+end_src

Podemos comprobar su validez con ~range~:

#+begin_src C++ :exports both :eval never-export :results output :includes '(<iostream> </home/hectarea/lispylambda/posts/C++/prueba.h>)
std::cout << length_v<range_t<box<17>>> << std::endl;
 #+end_src

 #+RESULTS:
 : 17

Perfecto.

A partir de aquí se vienen un poco de curvas. Vamos a definir las funciones ~zip~ y ~map~. El problema está en que ~map~ es fácil de implementar si tenemos ~zip~, pero ~zip~ es fácil de implementar si tienemos ~map~. Así que de alguna manera tenemos que ensuciarnos las manos con recursividad en alguna de las funciones. 

Empezaremos con una versión simplificada de ~map~: ~map_single~. Esta función crea una colección con los resultados de aplicar una función recibida a cada uno de los elementos de una colección recibida.

#+begin_src C++ :exports both :eval never-export :results output :includes '(<iostream> </home/hectarea/lispylambda/posts/C++/prueba.h>)
template<typename F, typename C>
struct map_single {};

template<typename F, typename... CS>
struct map_single<F, collection<>> : collection<> {};

template<typename F, typename C, typename... CS>
struct map_single<F, collection<C,CS..>>
  : cons<funcall_t<F,C>, typename map_single<F, collection<CS...>>::type> {};

canonize(map_single);
 #+end_src

Vamos a hacer una pequeña prueba:

#+begin_src C++ :exports both :eval never-export :results output :includes '(<iostream> </home/hectarea/lispylambda/posts/C++/prueba.h>)
std::cout << sum_v<map_single_t<add1_f, range_t<box<3>>>> << std::endl;
 #+end_src

 #+RESULTS:
 : 6

Perfecto. La llamada a ~range_t<box<3>>~ ha creado el tipo ~collection<box<0>,box<1>,box<2>>~. Al sumarle ~1~ a cada uno de estos elementos con ~add1_f~ conseguimos una colección con los números ~1~, ~2~ y ~3~. Y la suma de estos 3 números es, efectivamente, ~6~.

Con esto ya tenemos herramientas para crear ~zip~ de manera relativamente cómoda. Esta función recibe una cantidad variable de colecciones y creará una colección de colecciones. La primera colección contiene los primeros elementos de las colecciones recibidas. La segunda, los segundos elementos. Y así, hasta que alguna colección recibida no tenga más elementos. La complicación de esta función reside principalmente en ir comprobando que alguna de las colecciones se quede vacía para terminar la evaluación. Para ello, usamos una función ~zip_aux~ que recibe además un booleano indicando si debemos terminar o no, es decir, si alguna colección ya no tiene elementos.

#+begin_src C++ :exports both :eval never-export :results output :includes '(<iostream> </home/hectarea/lispylambda/posts/C++/prueba.h>)
template<bool stop, typename... CS>
struct zip_aux {};
 #+end_src

Si debemos parar devolvemos una colección vacía.

#+begin_src C++ :exports both :eval never-export :results output :includes '(<iostream> </home/hectarea/lispylambda/posts/C++/prueba.h>)
template<typename... CS>
struct zip_aux<false, CS...> : collection<> {};
 #+end_src

Si debemos seguir, necesitamos calcular varias cosas. 

Primero, debemos determinar si en la siguiente llamada deberemos continuar o no. Para ello, para cada una de las colecciones debemos eliminar el primer elemento y comprobar que la colección resultante está vacía. Si alguna de esas colecciones es vacía entonces debemos indicar con el valor ~true~ que debemos parar. Parecen muchas cosas, pero tenemos bastantes herramientas. Para poder eliminar el primer elemento de una colección usamos ~cdr~. Y si queremos hacerlo para cada colección basta usar ~map_single~. Es decir, si ~CS...~ son nuestras colecciones, entonces basta evaluar ~map_single_t<cdr_f,collection<CS...>>~. Ahora queremos saber si alguna de las colecciones que está dentro de la colección devuelta por la anterior llamada está vacía. Para saber si una colección está vacía usamos ~is_empty~. Si queremos usar la función para cada colección usamos de nuevo ~map_single_t~. La llamada a realizar, por ahora, sería ~map_single_t<is_empty_f,map_single_t<cdr_f,collection<CS...>>>~. Esto nos devuelve una colección de ~box~ de booleanos. Si alguno de estos booleanos es ~false~, entonces devolvemos ~false~. Eso es aplicar la operación lógica ~and~. Pero ~and_logic~ acepta una cantidad variable de booleanos, no una colección. No pasa nada, porque podemos usar ~apply~. Con todo esto la llamada final sería ~apply_v<and_logic_f,map_single_t<is_empty_f,map_single_t<cdr_f,collection<CS...>>>>~. 

En segundo lugar, debemos coger los primeros elementos de cada colección e introducirlos en una nueva. Como ~CS...~ son las colecciones que hemos recibido habría que evaluar los siguiente: ~collection<car_t<CS>...>~. Sencillo.

Por último, la parte de recursividad. Debemos llamar a la propia función ~zip~ con las colecciones recibidas habiendo eliminado el primer elemento. La llamada sería ~zip_aux<'el booleano de antes', cdr_t<CS>...>~. 

Ahora, para juntarlo todo, debemos coger la colección obtenida del segundo punto y añadirlo como primer elemento a la colección de colecciones obtenida por el tercer punto. 

#+begin_src C++
template<typename... CS>
struct zip_aux<false, CS...> 
  : cons<collection<car_t<CS>...>, 
         typename zip_aux<apply_v<and_logic_f,map_single_t<is_empty_f,map_single_t<cdr_f,collection<CS...>>>>,
                          cdr_t<CS>...>::type> {};
#+end_src

Ya solo queda crear ~zip~ usando ~zip_aux~. Todo el código quedaría así:

#+begin_src C++ :exports both :eval never-export :results output :includes '(<iostream> </home/hectarea/lispylambda/posts/C++/prueba.h>)
template<bool stop, typename... CS>
struct zip_aux {};

template<typename... CS>
struct zip_aux<true, CS...> : collection<> {};

template<typename... CS>
struct zip_aux<false, CS...> 
  : cons<collection<car_t<CS>...>, 
         typename zip_aux<apply_v<and_logic_f,map_single_t<is_empty_f,map_single_t<cdr_f,collection<CS...>>>>,
                          cdr_t<CS>...>::type> {};

template<typename... CS>
struct zip : zip_aux<apply_v<and_logic_f,map_single_t<is_empty_f,collection<CS...>>>,
                     CS...> {};

canonize(zip);
 #+end_src

Observa que para llamar a ~zip_aux~ en ~zip~ tenemos que comprobar también si alguna de las colecciones está vacía. Al menos no tenemos que eliminar el elemento inicial, por lo que la llamada es más sencilla.

Comprobamos su validez:

#+begin_src C++ :exports both :eval never-export :results output :includes '(<iostream> </home/hectarea/lispylambda/posts/C++/prueba.h>)
debug<zip_t<range_t<box<3>>, range_t<box<3>>>>::type;
 #+end_src

 #+RESULTS:

#+begin_src C++ :exports both :eval never-export :results output :includes '(<iostream> </home/hectarea/lispylambda/posts/C++/prueba.h>)
error: ‘type’ is not a member of ‘debug<
  collection<
    collection<box<0>, box<0>>, 
    collection<box<1>, box<1>>, 
    collection<box<2>, box<2>>>>’
 #+end_src

Perfecto. 

Ahora ya podemos definir la función ~map~. Esta función recibe una función y una cantidad variable de colecciones. Todos los primeros elementos de cada colección son pasados a la función recibida generando un valor que se almacena en una nueva colección. Y lo mismo ocurre para todos los segundos elementos, todos los terceros, etc. La forma de agrupar cada uno de esos elementos es sencilla ahora que disponemos de la función ~zip~. Luego, basta aplicar la función con los elementos de cada colección devuelta por ~zip~. Para esta última parte definiremos una función auxiliar ~map_aux~.

#+begin_src C++
template<typename F, typename C>
struct map_aux {};

template<typename F, typename... CS>
struct map_aux<F, collection<CS...>> : collection<apply_t<F,CS>...> {};

template<typename F, typename... CS>
struct map : map_aux<F, zip_t<CS...>> {};

canonize(map);
#+end_src

#+begin_src C++ :exports both :eval never-export :results output :includes '(<iostream> </home/hectarea/lispylambda/posts/C++/prueba.h>)
std::cout << sum_v<map_t<add_f, range_t<box<3>>, range_t<box<3>>>> << std::endl;
 #+end_src

 #+RESULTS:
 : 6

Lo que acabamos de hacer es generar con ~map_t~ una coleccion con 3 elementos. Cada elemento tiene la suma de los dos primeros, dos segundos y dos terceros elementos de cada ~range_t~. Es decir, devuelve la colección con los elementos ~0~, ~2~ y ~4~ que son el resultado de ~0+0~, ~1+1~ y ~2+2~. Luego sumamos los elementos de la colección obteniendo así el valor ~6~.

Espero que no te duela la cabeza... Porque todo esto ha sido sencillo, ¿verdad? Además, los templates son bastante legibles... Bueno, mira el lado positivo, con ~canonize~ tenemos que escribir menos.

* Curryficación
Aún recuerdo cuando, en mi último año de universidad, nuestra profesora de programación nos explicó la curryficación. No entendí nada. Y no fue su culpa, a ella la considero una de las mejores profesoras que podías encontrar en la facultad de informática. Fue con algunos ejemplos en Haskell cuando empecé a entender qué era la curryficación. Y puedo decir que fue el primer concepto de programación que me pareció magia. 

Todos sabemos lo que es una función. Un trozo de código parametrizado por unos argumentos. Para ejecutar una función debemos darle el número correcto de argumentos, y si no, pues se genera un error, normalmente de compilación. Pero en Haskell no ocurría lo mismo. Si a una función le das menos argumentos de los que la función debía recibir, no se generaba nigún error. En su lugar, se devolvía una nueva función. Una función que debía recibir el resto de argumentos que la función original no recibió en primer lugar. Cuando a esta nueva función le das todos los argumentos, entonces se ejecutaba la función original. Cuando una función se comporta de esta manera decimos que la función está *curryficada*. La función devuelta podría o no estar también curryficada.

El ejemplo más sencillo para entender la curryficación trata de usar la función ~suma~. La función ~suma~ suele recibir dos argumentos, ni uno más ni uno menos. 

#+begin_src C++
suma(3, 4);
#+end_src

Esta llamada daría el valor ~7~. Imaginemos ahora que intentamos ejecutar la misma función con sólo el argumento ~3~.

#+begin_src C++
nuevaFuncion = suma(3);
#+end_src

Esto devuelve una ~nuevaFuncion~ que requierirá sólo un argumento. Al recibir ese nuevo argumento, ejecutará la función original con el nuevo argumento y los que ya recibió anteriormente dicha función original.

#+begin_src C++
nuevaFuncion(4);
#+end_src

Esta llamada volvería a darnos el valor ~7~. 

Por tanto, podemos observar que la función devuelta por ~suma(3)~ es aquella que suma ~3~ al valor que reciba como parámetro.

El gran potencial de la curryficación reside en poder crear funciones al vuelo. Y es que es tan fácil crear una función como lo es pasarle menos argumentos a otra.

Las funciones que hemos visto hasta ahora en T++ no están curryficadas. Si intentamos pasar un número de argumentos insuficiente se generará un error de compilación. Por tanto, lo que debemos hacer es curryficarlas. La idea es muy sencilla, y es casi igual a lo que hicimos con ~function~. Recordemos cómo se implementó ~function~:

#+begin_src C++
  template<template<typename...> typename F>
  struct function{
	using type = function;

	template<typename... A>
	using call = typename F<A...>::type;
  };
#+end_src

El template ~function~ recibía un tipo templatizado ~F~ y es uno de sus miembros, ~call~, el que debía recibir los argumentos de dicho tipo. Al usar call, se 'ejecutaba' ~F~. 

Para crear una función curryficada usaremos la constante ~curry~. Y será muy parecida. La única diferencia es que, inicialmente, además de recibir un tipo templatizado también recibirá parte de los argumentos que necesita. Luego, el miembro ~call~ recibirá el resto:

#+begin_src C++
  template<template<typename...> typename F, typename... AS>
  struct curry{
	using type = curry;

	template<typename... BS>
	using call = typename F<AS...,BS...>::type;
  };
#+end_src

Veamos un ejemplo de cómo se usaría con la función ~add~. Vamos a crear una función que suma el valor ~3~. Para ello, le pasamos el argumento ~3~ a ~add~ mediante el uso de ~curry~:

#+begin_src C++ :exports both :eval never-export :results output :includes '(<iostream> </home/hectarea/lispylambda/posts/C++/prueba.h>)
using add3_f = curry<add, box<3>>;
std::cout << funcall_v<add3_f, box<4>> << std::endl;
#+end_src

#+RESULTS:
: 7

Al pasarle el valor 3 a la función curryficada, recibimos una nueva función que llamamos ~add3_f~. Luego la ejecutamos mediante ~funcall_v~ pasándole el argumento ~4~. 

Esto ya es más cómodo que crear una nueva función como las que hemos creado hasta ahora. E incluso podemos hacerlo mejor. Con ~curry~ realmente no estamos curryficando nada. Lo ideal sería tener algo como ~add_c~ que represente de verdad una función curryficada. De hecho, crear esa función curryficada es sencillo:

#+begin_src C++
template<typename... AS>
using add_c = curry<add, AS...>;
#+end_src

#+begin_src C++ :exports both :eval never-export :results output :includes '(<iostream> </home/hectarea/lispylambda/posts/C++/prueba.h>)
using add3_f = add_c<box<3>>;
std::cout << funcall_v<add3_f, box<4>> << std::endl;
#+end_src

#+RESULTS:
: 7

Si tuviésemos una forma de curryficar todas las funciones... 

¡¡ ~canonize~!!

Vamos a añadir la curryficación a ~canonize~, de esta forma todas nuestras funciones tendrán una versión curryficada:

#+begin_src C++
#define canonize(name)                                  \
  template<typename... TS>                              \
  using name##_t = typename name<TS...> ::type;         \
                                                        \
  template<typename... TS>                              \
  static constexpr auto name##_v = name<TS...> ::value; \
                                                        \
  template<typename... TS>                              \
  using name##_vt = typename name<TS...>::value_type;   \
                                                        \
  using name##_f = function<name>;                      \
                                                        \
  template<typename... TS>                              \
  using name##_c = curry<name, TS...>;
#+end_src
 
Vamos a probar:

#+begin_src C++ :exports both :eval never-export :results output :includes '(<iostream> </home/hectarea/lispylambda/posts/C++/prueba.h>)
using first_five = range_t<box<5>>;
using next_first_five = map_t<add_c<box<10>>, first_five>;  
std::cout << sum_v<next_first_five> << std::endl;
#+end_src

#+RESULTS:
: 60

Vayamos paso a paso. En la primera línea se crea la colección ~{0,1,2,3,4}~. En la siguiente línea sumamos ~10~ a cada uno de los elementos de la colección. Observa que sin la curryficación tendríamos que haber definido una función llamada ~add10~ o algo parecido. Con esta segunda línea se genera la colección ~{10,11,12,13,14}~. Y por último sumamos los valores de la colección: ~10+11+12+13+14 = 60~.

* El intérprete
No hay duda de que la curryficación de funciones nos facilita la vida. Pero lo que nadie se esperaba era que podemos aprovecharnos de cómo funciona la constante ~curry~ para simular un intérprete. El intérprete que vamos a definir es muy simple. Su trabajo será el de ir evaluando los argumentos de una función. Si el argumento es otra función, tendrá que evaluar también sus argumentos. Es decir, el intérprete irá evaluando de manera recursiva las funciones que se vaya encontrando.

Lo mejor de todo, es que implementar este intérprete no es para nada complicado. A la función que hará de intérprete la llamaremos ~interpret~.

#+begin_src C++
template<typename T>
struct interpret : T {};

template<template<typename...> typename F, typename... AS>
struct interpret<curry<F,AS...>> : funcall<curry<F,typename interpret<AS>::type...>> {};

canonize(interpret);
#+end_src

Analicemos esta función. Observa en la versión general que lo que se devuelve es el propio tipo. Es decir, actúa como ~identity~. Esto es así porque un intérprete, al evaluar una constante, debe devolver dicha constante. Por otro lado, tenemos la versión especializada para la constante ~curry~. Lo que se hace es ejecutar la función curryficada, pero en lugar de usar los argumentos que había recibido la función curryficada, se interpretan los argumentos.

Este intérprete cambia radicalmente cómo se usan las funciones curryficadas. Veamos el ejemplo siguiente. 

#+begin_src C++ :exports both :eval never-export :results output :includes '(<iostream> </home/hectarea/lispylambda/posts/C++/prueba.h>)
std::cout << add_v<add_t<box<1>,box<2>>, box<5>> << std::endl;
#+end_src

#+RESULTS:
: 8

Para evaluar ~add_v~ primero se ha tenido que evaluar ~add_t~. El resultado que devuelve, ~box<3>~ en este caso, se sumará a ~box<5>~. Veamos ahora el mismo ejemplo usando ~interpret~:

#+begin_src C++ :exports both :eval never-export :results output :includes '(<iostream> </home/hectarea/lispylambda/posts/C++/prueba.h>)
std::cout << interpret_v<add_c<add_c<box<1>,box<2>>, box<5>>> << std::endl;
#+end_src

#+RESULTS:
: 8

Observa cómo se están usando ambas llamadas a ~add~. Se está usando la versión curryficada. Recordemos cómo funcionaba ~interpret~. El intérprete iba recorriendo los argumentos evaluándolos. En este caso, ~interpret~ va a evaluar el primer ~add_c~ pero para ello primero evaluará el segundo ~add_c~ y ~box<5>~. Para evaluar ~add_c~ primero se van a evaluar ~box<1>~ y ~box<2>~. Y no nos olvidemos de que el intérprete deja intactas las constantes, que para eso las hemos llamado así. Por tanto, el orden de evaluación sería el siguiente:

1. ~box<1>~ --> ~box<1>~
2. ~box<2>~ --> ~box<2>~
3. ~add_c<box<1>,box<2>>~ --> ~box<3>~
4. ~box<5>~ --> ~box<5>~
5. ~add_c<box<3>,box<5>>~ --> ~box<8>~

Además, lo más importante de todo es que ahora ya no nos tenemos que preocupar de pensar si hay que usar ~_v~, ~_t~, ~_f~ o ~_vt~. Ahora sólo usamos ~_c~. Esto hace que programar sea más intuitivo. El único sitio donde nos preocupamos sobre el alias es con ~eval~.

Espera un momento... Vamos a observar de nuevo el ejemplo:

#+begin_src C++
interpret_v<add_c<add_c<box<1>,box<2>>, box<5>>>
#+end_src

Mmmm... ¿Qué pasaría si renombrásemos ~add_c~ por ~add~?

#+begin_src C++
interpret_v<add<add<box<1>,box<2>>, box<5>>>
#+end_src 

Quiero decir... si cambiamos todos los alias que acaban por ~_c~ para que sean como su nombre original... sería casi como programar en un lenguaje normal... Claramente habría que cambiar también el nombre original para que no haya colisión de nombres, pero sería todo mucho más cómodo...

Creo que... vale la pe... in.. no me encuentro muy bien... uff...

¿Lo cambiamos todo...? Haber... ufff... no... no pued... eEeEezZZzddduuññÑñ3Oo4UuttTssPppp5LlrRRiIiGgaaAaZVIUAHVISLVHOWUIVhAUWEVNÑUAOWNVVHUWLABVEUWeuoliahfepuasbhncvjeulanhufisa011235813213455546F646F20656C206D756E646F20657374C3A120636965676F2E2053C3B36C6F207573616E2066756E63696F6E65732E2045736F2065732070726F6772616D61722061206D65646961732E204C6173206D6174656DC3A1746963617320646566696E656E206C617320462DC3A16C6765627261732E204C617320462DC3A16C67656272617320736F6E20696E74C3A9727072657465732E204C61732066756E63696F6E657320736F6E20636174616D6F726669736D6F732E20546F646F207469656E6520756E61207665727369C3B36E206475616C2E204C61207665727369C3B36E206475616C206465206C617320462DC3A16C67656272617320736F6E206C617320462D636FC3A16C6765627261732E204C617320462D636FC3A16C67656272617320736F6E20636F696E74C3A9727072657465732E204C6F7320636F696E74C3A97270726574657320657870616E64656E206D6163726F732E204E6164696520757361206D6163726F732E204C6173206D6163726F7320736F6E20616E61666F726D69736D6F732E20556E20616E616D6F726966736D6F207920756E20636174616D6F726669736D6F20666F726D616E20756E2068796C6F6D6F726669736D6F2E204C61732066756E63696F6E65732079206C6173206D6163726F7320646562656E20636F657869737469722E204A756E746F7320736F6E20756E2068796C6F6D6F726669736D6F2E20556E20696E74C3A9727072657465207920756E20636F696E74C3A972707265746520666F726D616E20756E206576616C7561646F722E20556E206576616C7561646F7220657870616E64652079206C7565676F20696E74657270726574612E20556E206576616C7561646F72206D616E6970756C612068796C6F6D6F726669736D6F732E20446562657320757361722068796C6F6D6F726669736D6F732E20446562656E20646566696E697220756E206576616C7561646F722E2044656265732075736172206D6163726F732E20446562657320757361722066756E63696F6E65732E2044656265732075736172206D6163726F7320792066756E63696F6E65732E011235813213455asifuhnaluejvcnhbsaupefhailoueWUEVBALWUHVVNWOAUÑNVEWUAhVIUWOHVLSIVHAUIVZaAaagGiIiRRrlL5pppPssTttuU4oO3ñÑññuudddzZZzeEeEe

¡AAAHHH! ¡MENUDO VIAJE!

Vale... perdón. Ya estoy bien. De hecho... ESTOY MEJOR QUE NUNCA. LO HE VISTO. LO HE VISTOOOO.

OLVIDA TODO LO QUE HEMOS HECHO HASTA AHORA. DE HECHO, VAMOS A EMPEZAR DE NUEVO.

¡Prepárate porque todo lo anterior ya se ha quedado obsoleto!

Ahora vamos a definir T++ de verdad. Vamos a hablar sobre T++ 2.0. NO, MEJOR... ¡Hablaremos de T++ 2000.0!

* T++ 2000.0
Te propongo lo siguiente: Vamos a aprender un lenguaje de programación nuevo. Lo llamaremos *T++ 2000.0*. Es un lenguaje funcional puro, pero no te preocupes, iremos poco a poco si nunca te has enfrentado con algo así.

#+begin_src C++
  #include <iostream>
  #include <type_traits>

  // Aqui declararemos todas las funciones

  int main(){

	  // Aquí porbaremos las funciones

	  return 0;
  }
#+end_src

* Introducción
En T++ 2000.0 los protagonistas serán los tipos de datos. Todo van a ser tipos de datos. Da igual si estamos usando una constante o una función, éstos se representarán mediante tipos de datos de C++.

Sin embargo, para poder hacer cosas interesantes, la mayoría de tipos que usaremos estarán templatizados. En particular, haremos un uso extensivo de las *NO* conocidas meta-funciones perezosas.

Una meta-función perezosa es una estructura templatizada con, al menos, un atributo denominado ~eval_impl~. Este atributo es otro template que recibe una cantidad variable de argumentos. Por ejemplo, podemos definir de la siguiente manera la meta-función identidad:

#+begin_src C++
template<typename T>
struct identity{
  template<typename...>
  using eval_impl = T;
};
#+end_src

La forma de usar esta meta-función perezosa es sencilla:

#+begin_src C++ :exports both :eval never-export :results output :includes '(<iostream> </home/hectarea/lispylambda/posts/C++/prueba2.h>)
identity<int>::eval_impl<> myInteger = 3;
std::cout << myInteger << std::endl;
#+end_src

#+RESULTS:
: 3

Observa cómo se está usando ~identity<int>::eval_impl<>~. La meta-función perezosa ~identity~ está recibiendo el argumento ~int~ que lo devuelve a través de ~eval_impl~.

Cuando usamos una meta-función perezosa de esta manera decimos que estamos *evaluando* la meta-función. De hecho, diremos que una meta-función es *evaluable* si contiene el atributo ~eval_impl~.

Sólo queda decir que meta-funciones evaluables van a ser el núcleo de T++ 2000.0 y serán lo que nos permita hacer cosillas interesantes en tiempo de compilación.

* Constantes
Y sin esperar mucho más, vamos a definir cuáles van a ser las constantes en T++ 2000.0. Decimos que un tipo de C++ es una *constante* en T++ si es una meta-función evaluable que se *evalúa* a sí misma. Aunque parezca raro, esto se puede hacer sin problemas.

Desde el estándar C++17 es válido indicar como argumento de un template un valor con el especificador ~auto~. De esta forma podemos conseguir definir una constante que represente un puente entre T++ 2000.0 y C++ para todos los valores primitivos de C++.

#+begin_src C++
template<auto b>
struct box{
  using type = decltype(b);
  static constexpr auto value = b;

  template<typename...>
  using eval_impl = box;
};
#+end_src

Vamos a probar:

#+begin_src C++ :exports both :eval never-export :results output :includes '(<iostream> </home/hectarea/lispylambda/posts/C++/prueba2.h>)
std::cout << box<5>::eval_impl<>::value << std::endl;
#+end_src

#+RESULTS:
: 5

¡Genial!

La constante ~box~ introducida justo ahora nos permite tener una *constante* que además nos sirve de puente entre C++ y T++ 2000.0. Además, hemos dicho que una *constante* en T++ 2000.0 es una meta-función perezosa que se *evalúa* a sí misma. 

Observa además que tenemos una gran diferencia con respecto a la definición que teníamos en T++. El atributo ~type~ ahora devuelve el tipo del valor ~b~. Además, ya no está el atributo ~value_type~. A partir de ahora, queremos que haya una diferencia clara entre qué pertenece a C++ (los atributos ~type~ y ~value~) y qué pertenece a T++ 2000.0 (el atributo ~eval~).  

Por otro lado, también existen tipos en C++ que ni siquiera son meta-funciones. Hablamos de tipos como ~int~ o ~float~. Estos tipos también pertenecen a C++ y no a T++ 2000.0. Por lo que nos va a interesar crear otro puente.

Aquí definimos la *constante* de T++ 2000.0 ~tbox~. Va a funcionar igual que ~box~, pero en lugar de recibir un valor, recibimos un tipo de C++. 

#+begin_src C++
template<typename T>
struct tbox{
  using type = T;

  template<typename...>
  using eval_impl = tbox;
};
#+end_src

* El evaluador
Seamos sinceros... Usar ~eval_impl<>~ para evaluar una meta-función perezosa es incómodo. Sólo hace falta ver el último ejemplo:

#+begin_src C++
std::cout << box<5>::eval_impl<>::value << std::endl;
#+end_src

Hasta duele un poco a los ojos.

Pero esto tiene solución. Sólo tenemos que hacer una meta-función que evalúe por nosotros. Esta meta-función será el evaluador de T++ 2000.0 y lo llamaremos ~tpp~. 

La definición de ~tpp~ es tan simple como esto:

#+begin_src C++
  template<typename T>
  using tpp = typename T::eval_impl<>;
#+end_src

Observa que ~tpp~ no es un nuevo ~struct~. Es una alias para ~T::eval_impl<>~. Esto es así porque queremos que ~tpp<T>~ sea ya el objeto al que se evalúa ~T~. Si ~tpp~ fuese un ~struct~ entonces ~tpp<T>~ sería un nuevo tipo de dato de C++ que hereda del objeto al que se evalúa ~T~. Es definitiva, no queremos un nuevo tipo, queremos que sea literalmente el objeto devuelto por ~T~.

Podemos pensar en ~tpp~ como la meta-función que nos permite escribir código de T++.

Además, para poder acceder fácilmente a sus atributos generamos los famosos alias:

#+begin_src C++
  template<typename T>
  using tpp = T::eval_impl<> {};

  template<typename T>
  extern constexpr auto tpp_v = tpp<T>::value;

  template<typename T>
  using tpp_t = tpp<T>::type;'
#+end_src

Probemos ahora a evaluar la constante ~box<5>~ usando ~tpp~:

#+begin_src C++ :exports both :eval never-export :results output :includes '(<iostream> </home/hectarea/lispylambda/posts/C++/prueba2.h>)
std::cout << tpp_v<box<5>> << std::endl;
#+end_src

#+RESULTS:
: 5

¡Mucho mejor!

* Implementaciones
Una vez hemos visto las constantes necesitamos algo que nos permita hacer cálculos con ellos. Y ahí es cuando entran las funciones. Definimos las funciones en T++ 2000.0 a aquellas meta-funciones evaluables que evalúan sus argumentos para luego devolver otra meta-función evaluable.

Para conseguir definir funciones necesitamos primero implementar el comportamiento de la función. Por ejemplo, podemos implementar el comportamiento de una función que reciba dos enteros (~box<n>~ con ~n~ de tipo ~int~) y que devuelva la suma:

#+begin_src C++
template<typename A, typename B>
struct add2_impl : box<A::value + B::value>{};
#+end_src

Aquí asumimos que los argumentos están *evaluados*. Además, hemos añadido el sufijo ~_impl~ para hacer énfasis de que es sólo la implementación. Esto *NO* es una función de T++ 2000.0.

La implementación de suma se puede generalizar para que acepte una cantidad variable de argumentos:

#+begin_src C++
template<typename... NS>
struct add_impl : box<0>{};

template<typename N, typename... NS>
struct add_impl<N,NS...> : box<N::value+add<NS...>::value> {};
#+end_src

* Funciones
Las funciones van a ser meta-funciones evaluables. Es decir, necesitan tener un atributo ~eval_impl~. 

Recordemos que las funciones tienen que *evaluar* los argumentos antes de usar la implementación. La definición es la siguiente:

#+begin_src C++
template<template<typename...> typename F, typename... AS>
struct make_function{
  template<typename...>
  using eval_impl = tpp<F<tpp<AS>...>>;
};
#+end_src

La meta-función ~function~ recibe como primer parametro una implementación y seguidamente sus argumentos. 

A la hora de evaluar la función, primero se evalúan los argumentos de la implementación ~F~ mediante ~tpp<AS>...~ y a continuación se evalúa de nuevo ~F<tpp<AS>...>~ para obtener el resultado.

Como ya tenemos la implementación de la suma (~add_impl~) vamos a probar a crear su función correspondiente. Recordemos primero dicha implementación:

#+begin_src C++
template<typename... NS>
struct add_impl : box<0>{};

template<typename N, typename... NS>
struct add_impl<N,NS...> : box<N::value+add_impl<NS...>::value> {};
#+end_src

Con esto, basta escribir lo siguiente:

#+begin_src C++
  template<typename... TS>
  using add = make_function<add_impl, TS...>;
#+end_src

¡Hecho! Ahora sí, ~add~ es una función de T++ 2000.0. Podemos usar ahora ~tpp~ para evaluar la función:

#+begin_src C++ :exports both :eval never-export :results output :includes '(<iostream> </home/hectarea/lispylambda/posts/C++/prueba2.h>)
std::cout << tpp_v<add<box<3>,box<6>,box<10>>> << std::endl;
#+end_src

#+RESULTS:
: 19

Y lo mejor de todo, es que podemos usar ~add~ como un argumento del propio ~add~. Porque recuerda, ~add~ es un objeto y el propio ~add~ evalúa los argumentos:

#+begin_src C++ :exports both :eval never-export :results output :includes '(<iostream> </home/hectarea/lispylambda/posts/C++/prueba2.h>)
std::cout << tpp_v<  add<  add<box<3>,box<6>>,  box<10>  >  > << std::endl;
#+end_src

#+RESULTS:
: 19

Es decir, en este caso, el orden de evaluación sería el siguiente:

1. ~box<3>~ -> ~box<3>~
2. ~box<3>~ -> ~box<6>~
3. ~add<box<3>,box<6>>~ -> ~box<9>~
4. ~box<10>~ -> ~box<10>~
5. ~add<box<9>,box<10>>~ -> ~box<19>~

Finalmente, fíjate que no hemos definido ningún alias para nuestra función. Los únicos alias que necesitaremos son los ya definidos para ~tpp~.

* If Then Else
En T++ era simplemente imposible crear algo como un ~If Then Else~ debido a que los argumentos de un template normalmente se evalúan de forma ansiosa. Es decir, no podemos elegir qué argumentos se evalúan y cuáles no (al menos con facilidad). Pero T++ 2000.0 está a otro nivel. Aquí todo es posible.

Para implementar un ~If Then Else~ necesitamos crear un nuevo tipo de meta-función evaluable. Vamos a elegir el nombre ~branch~ para nuestro ~If Then Else~ ya que ~if~ está cogido por C++. Lo que debe de hacer ~branch~ es *evaluar* primero la condición. Si el resultado es verdadero, entonces *evaluamos* el ~Then~, y si no, *evaluamos* el ~Else~. ¡Y ya está! Esta sería la definición.

#+begin_src C++
template<typename C, typename T, typename E>
struct branch : branch<eval<C>,T,E> {};

template<typename T, typename E>
struct branch<box<true>,T,E> : eval<T> {};

template<typename T, typename E>
struct branch<box<false>,T,E> : eval<E> {};
#+end_src 

Vamos arealizar primero una pequeña prueba:

#+begin_src C++ :exports both :eval never-export :results output :includes '(<iostream> </home/hectarea/lispylambda/posts/C++/prueba2.h>)
std::cout << eval_v<branch<box<true>,box<10>,box<15>>> << std::endl;
std::cout << eval_v<branch<box<false>,box<10>,box<15>>> << std::endl;
#+end_src

#+RESULTS:
: 10
: 15

¡Genial! Por ahora funciona. Aunque será mejor probar con algo más complicado.

* Recursividad
Ya en T++ se usaba la recursividad de manera recurrente. Aunque en T++ 2000.0 se hace más evidente y, a la vez, sencillo.

Para demostrar cómo vamos a usar la recursividad en T++ 2000.0 vamos a definir la función de FIbonacci.

Recordemos que esta función debe recibir un entero y devolver el elemento n-ésimo de la sucesión de Fibonacci. El primer elemento de esa sucesión es el ~0~, el segundo el ~1~, y el resto se calcula sumando los dos anteriores.

En particular, si la función recibe un ~0~ o un ~1~, devolvemos el mismo valor. Si recibimos un valor más grande sumamos los dos valores anteriores realizando llamadas recursivas.

Por último, necesitaremos un par de funciones extra: ~sub1~ y ~eql~. Sus definiciones son las siguientes:

#+begin_src C++
/// sub1
template<typename N>
struct sub1_impl : box<N::value - 1> {};

template<typename N>
using sub1 = make_function<sub1_impl,N>;

/// eql
template<typename N, typename M>
struct eql_impl : box<N::value == M::value> {};

template<typename N, typename M>
using eql = make_function<eql>;
#+end_src

Ahora sí, empezamos definiendo la función escribiendo la declaración de su implementación:

#+begin_src C++
template<typename N>
struct fibonacci_impl;
#+end_src

Y, antes de escribir la implementación, creamos ya la función. De esta forma podremos usar el objeto en la propia implementación.

#+begin_src C++
template<typename N>
using fibonacci = make_function<fibonacci_impl, N>;
#+end_src

Y sólo queda ya la implementación que escribiremos usando ~branch~:

#+begin_src C++
template<typename N>
struct fibonacci_impl
  : branch<eql<N,box<0>>,
           box<0>,
           branch<eql<N,box<1>>,
                  box<1>,
                  add<fibonacci<sub1<N>>, fibonacci<sub1<sub1<N>>>>>> {};
#+end_src

No hay mucho más que explicar aquí, es el típico algoritmo de Fibonacci. Vamos a probar:

#+begin_src C++ :exports both :eval never-export :results output :includes '(<iostream> </home/hectarea/lispylambda/posts/C++/prueba2.h>)
std::cout << eval_v<fibonacci<box<10>>> << std::endl;
#+end_src

#+RESULTS:
: 55

¡Perfecto! Si te soy sincero, nunca pensé que podría utilizar un ~If Then Else~ en los templates de C++. ¡Pero ahí está! ¡Y funciona de maravilla!

* Mucho texto...
Yo soy muy perezoso. Y como tal, tengo que buscar formas para escribir lo menos posible. Ya hemos definido varias funciones y me da la sensación de que hay que escribir demasiado.

Por ejemplo, volvamos a ver la función de suma:

#+begin_src C++
template<typename... NS>
struct add_impl : box<0>{};

template<typename N, typename... NS>
struct add_impl<N,NS...> : box<N::value+add_impl<NS...>::value> {};

template<typename... NS>
using add = make_function<add_impl>;
#+end_src

Está claro que la implementación se tiene que quedar, pero ya vimos en T++ que podemos ahorrarnos los alias (en este caso ~add~) con una macro de C++. Y aquí no va a ser menos. Como lo que estamos haciendo es definir una función, voy a denominar a la macro como ~defun~.

#+begin_src C++
#define defun(name)                                \
  template<typename... TS>                         \
  using name = make_function<name##_impl, TS...>;
#+end_src

Ahora la definición de la suma sería:

#+begin_src C++
template<typename... NS>
struct add_impl : box<0>{};

template<typename N, typename... NS>
struct add_impl<N,NS...> : box<N::value+add_impl<NS...>::value> {};

defun(add);
#+end_src

¡Bien! Más cortito. Aunque podemos hacerlo mejor.

Recordemos ahora la definición de ~fibonacci~:

#+begin_src C++
template<typename N>
struct fibonacci_impl;

template<typename N>
using fibonacci = make_function<fibonacci_impl, N>;

template<typename N>
struct fibonacci_impl
  : branch<eql<N,box<0>>,
           box<0>,
           branch<eql<N,box<1>>,
                  box<1>,
                  add<fibonacci<sub1<N>>, fibonacci<sub1<sub1<N>>>>>> {};
#+end_src

Con la nueva macro pasaríamos a tener lo siguiente:

#+begin_src C++
template<typename N>
struct fibonacci_impl;

defun(fibonacci);

template<typename N>
struct fibonacci_impl
  : branch<eql<N,box<0>>,
           box<0>,
           branch<eql<N,box<1>>,
                  box<1>,
                  add<fibonacci<sub1<N>>, fibonacci<sub1<sub1<N>>>>>> {};
#+end_src

Algo mejor, pero no está perfecto. Y es que me mosquea la declaración de arriba. De hecho, creo que podemos meterla dentro de la macro. De esta forma, para cualquier función que definamos podremos usar recursividad. ¡Dos pájaros de un tiro!

#+begin_src C++
#define defun(name)                                \
  struct name##_impl;                              \
                                                   \
  template<typename... TS>                         \
  using name = make_function<name##_impl, TS...>;
#+end_src

Ahora se tendría:

#+begin_src C++
template<typename N>
defun(fibonacci);

template<typename N>
struct fibonacci_impl
  : branch<eql<N,box<0>>,
           box<0>,
           branch<eql<N,box<1>>,
                  box<1>,
                  add<fibonacci<sub1<N>>, fibonacci<sub1<sub1<N>>>>>> {};
#+end_src

No sé, no sé... No me acaba de gustar. Es un poco raro tener ese ~template<typename N>~ arriba de ~defun~. ¿Y si lo metemos también en la macro? Sí... Creo que puede funcionar. Como cada función tiene unos argumentos diferentes, recibiremos estos argumentos como argumentos de la macro:

#+begin_src C++
#define defun(name, ...)                           \
  template<__VA_ARGS__>                            \
  struct name##_impl;                              \
                                                   \
  template<typename... TS>                         \
  using name = make_function<name##_impl, TS...>;
#+end_src

Veamos cómo quedaría:

#+begin_src C++
defun(fibonacci, typename N);

template<typename N>
struct fibonacci_impl
  : branch<eql<N,box<0>>,
           box<0>,
           branch<eql<N,box<1>>,
                  box<1>,
                  add<fibonacci<sub1<N>>, fibonacci<sub1<sub1<N>>>>>> {};
#+end_src

Oh... ¡Me gusta! ¡Es casi como definir una función de manera normal y corriente!

Volvamos a definir ~add~, ~eql~ y ~sub1~:

#+begin_src C++
/// add
defun(add, typename... NS);

template<typename... NS>
struct add_impl : box<0>{};

template<typename N, typename... NS>
struct add_impl<N,NS...> : box<N::value+add_impl<NS...>::value> {};

/// sub1
defun(sub1, typename N);

template<typename N>
struct sub1_impl : box<N::value - 1> {};

/// eql
defun(eql, typename N, typename M);

template<typename N, typename M>
struct eql_impl : box<N::value == M::value> {};
#+end_src

Me gusta, me gusta...

Probemos si funciona:

#+begin_src C++ :exports both :eval never-export :results output :includes '(<iostream> </home/hectarea/lispylambda/posts/C++/prueba2.h>)
std::cout << eval_v<add<fibonacci<box<10>>,box<100>>> << std::endl;
#+end_src

#+RESULTS:
: 155

¡Perfecto!

Antes de seguir, vamos a definir también todas las funciones que vimos en T++ por si nos sirviesen más adelante:

#+begin_src C++
/// add
defun(add, typename... NS);

template<typename... NS>
struct add_impl : box<0>{};

template<typename N, typename... NS>
struct add_impl<N,NS...> : box<N::value+add_impl<NS...>::value> {};

/// mult
defun(mult, typename... NS);

template<typename... NS>
struct mult_impl : box<1> {};

template<typename N, typename... NS>
struct mult_impl<N,NS...> : box<N::value * mult_impl<NS...>::value> {};

// sub
defun(sub, typename... NS);

template<typename... NS>
struct sub_impl : box<0>{};

template<typename N, typename... NS>
struct sub_impl<N,NS...> : box<N::value-sub_impl<NS...>::value> {};

/// quotient
defun(quotient, typename... NS);

template<typename... NS>
struct quotient_impl : box<1> {};

template<typename N, typename... NS>
struct quotient_impl<N,NS...> : box<N::value / quotient_impl<NS...>::value> {};

/// is_zero
defun(is_zero, typename T);

template<typename T>
struct is_zero_impl : box<false>{}; 

template<>
struct is_zero_impl<box<0>> : box<true> {};

/// or_logic
defun(or_logic, typename... NS);

template<typename... NS>
struct or_logic_impl : box<false>{};

template<typename N, typename... NS>
struct or_logic_impl<N,NS...> : box<N::value || or_logic_impl<NS...>::value> {};

/// and_logic
defun(and_logic, typename... NS);

template<typename... NS>
struct and_logic_impl : box<true>{};

template<typename N, typename... NS>
struct and_logic_impl<N,NS...> : box<N::value && and_logic_impl<NS...>::value> {};

/// not_logic
defun(not_logic, typename B);

template<typename B>
struct not_logic_impl : box<!B::value> {};

/// add1
defun(add1, typename N);

template<typename N>
struct add1_impl : add<N,box<1>> {};

/// sub1
defun(sub1, typename N);

template<typename N>
struct sub1_impl : box<N::value - 1> {};

/// eql
defun(eql, typename N, typename M);

template<typename N, typename M>
struct eql_impl : box<N::value == M::value> {};
#+end_src

* Quotation

#+begin_src C++ :exports both :eval never-export :results output :includes '(<iostream> </home/hectarea/lispylambda/posts/C++/prueba2.h>)
  std::cout << tpp_v<eval<quote<fibonacci<box<10>>>>> << std::endl;
#+end_src

#+RESULTS:
: 55


* Macros
¿Macros? ¡Macros! Y no las de C++. Macros en nuestro evaluador. Las macros son como las funciones, pero trabajan de un manera un pelín diferente. En una macro, los argumentos se reciben sin evaluar. Sin embargo, es el resultado lo que sí se evalúa.

Para nuestra primera macro vamos a definir ~cond~. Esta macro recibe una cantidad variable de argumentos. Estos argumentos van en parejas de ~condición~ y ~expresión~. Cuando se encuentre la primera condición veradera, se evaluará la expresión correspondiente. Si no se encuentra ninguna expresión verdadera se generará un error.

Como no queremos que se evalúen todos los argumentos, ~cond~ no puede ser una función. 

La idea para implementar ~cond~ es sencilla. Es usar ~If Then Else~ hasta encontrar la condición verdadera. Vamos a empezar:

#+begin_src C++
template<typename... CT>
struct cond_impl {};

template<typename C, typename T, typename... ES>
struct cond_impl<C,T,ES...> : eval<branch<C,T,cond<ES...>>> {};
#+end_src

La implementación es sencilla. Recuerda que queremos usar el cointérprete. Recordemos su definición:

#+begin_src C++
template<template<typename...> typename F, typename... AS>
struct eval<cocurry<F,AS...>>
  : eval<typename funcall_impl<cocurry<F,AS...>>::type> {};
#+end_src

Fíjate que el resultado de ~cond_impl~ también se va a evaluar. Por otro lado, si queremos que ~cond~ sea usado por el cointérprete necesitamos cocurryficarlo. Vamos allá:

#+begin_src C++
template<typename... CT>
  using cond = cocurry<cond_impl, CT...>;
#+end_src

Aunque yo ahí veo mucho texto... Ya sabemos lo que hacer, ¿verdad? Vamos definir una macro de C++ llamada ~defmacro~:

#+begin_src C++
#define defmacro(name)                          \
  template<typename... TS>                      \
  using name = cocurry<name##_impl, TS...>;
#+end_src

De esta forma, nuestra definición completa de la macro ~cond~ sería esta:

#+begin_src C++
template<typename... CT>
struct cond_impl {};

defmacro(cond);

template<typename C, typename T, typename... ES>
struct cond_impl<C,T,ES...> : eval<branch<C,T,cond<ES...>>> {};
#+end_src

Ponemos de nuevo ~defmacro~ justo antes de la implementación por comodidad. Vamos a probarla redefiniendo la función de fibonacci:

#+begin_src C++
template<typename N>
struct fibonacci_impl;

defun(fibonacci);

template<typename N>
struct fibonacci_impl
  : eval<cond<is_zero<N>,    box<0>,
              eql<N,box<1>>, box<1>,
              box<true>,     add<fibonacci<sub1<N>>, fibonacci<sub1<sub1<N>>>>>> {};
#+end_src

¿No es preciosa ahora esta nueva definición? Es mucho más legible que el anterior ~branch~. Observa que la última condición es ~box<true>~. Esta es la forma que tenemos para indicar un valor por defecto en ~cond~.

Vamos a probar de nuevo:

#+begin_src C++ :exports both :eval never-export :results output :includes '(<iostream> </home/hectarea/lispylambda/posts/C++/prueba2.h>)
std::cout << eval_v<fibonacci<box<10>>> << std::endl;
#+end_src

#+RESULTS:

Analicemos detalladamente qué está pasando aquí. En primer lugar, ~fibonacci~ se sustituye por ~curry<fibonacci_impl,...>~ que devolverá ~eval<cond<is_zero<N>, box<0>, ...>>~. Aquí, ~cond~ es un ~cocurry~ y por tanto los argumentos no se evalúan. Es decir, ~cond~ va a querer devolver ~branch<is_zero<N>, box<0>, cond<...>>~ que dentro de ~cond~ se evalúa a ~cond<box<true>, add<fibonacci<...>,fibonacci<...>>>~ ya que ~N~ al inicio es ~10~. Pero ahora recuerda que estamos usando el cointérprete: Los argumentos no se evaluaban pero el resultado sí. Es decir, cond<add<fibonacci<...>,fibonacci<...>>>


#+begin_src C++ :exports both :eval never-export :results output :includes '(<iostream> </home/hectarea/lispylambda/posts/C++/prueba2.h>)
std::cout << eval_v<fibonacci<box<10>>> << std::endl;
#+end_src

#+RESULTS:
: 55

